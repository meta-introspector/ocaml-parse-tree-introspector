Entering directory '/mnt/data1/nix/time/2024/08/12/ocaml_introspector'
Shared cache: disabled
Shared cache location: /home/mdupont/.cache/dune/db
Workspace root: /mnt/data1/nix/time/2024/08/12/ocaml_introspector
Auto-detected concurrency: 24
Dune context:
 { name = "default"
 ; kind = "default"
 ; profile = Dev
 ; merlin = true
 ; fdo_target_exe = None
 ; build_dir = In_build_dir "default"
 ; installed_env =
     map
       { "INSIDE_DUNE" :
           "/mnt/data1/nix/time/2024/08/12/ocaml_introspector/_build/default"
       }
 ; instrument_with = []
 }
Actual targets:
- alias @@lib/default
Done: 100% (2/2, 0 left) (jobs: 0)                                  Running[1]: (cd _build/default && /home/mdupont/.opam/4.14.0/bin/ocamlc.opt -w @1..3@5..28@31..39@43@46..47@49..57@61..62@67@69-40 -strict-sequence -strict-formats -short-paths -keep-locs -w -49 -nopervasives -nostdlib -g -bin-annot -I lib/.Typing.objs/byte -no-alias-deps -opaque -o lib/.Typing.objs/byte/typing.cmo -c -impl lib/typing.ml-gen)
Done: 100% (2/2, 0 left) (jobs: 0)                                  Running[2]: (cd _build/default && /home/mdupont/.opam/4.14.0/bin/ocamlopt.opt -w @1..3@5..28@31..39@43@46..47@49..57@61..62@67@69-40 -strict-sequence -strict-formats -short-paths -keep-locs -w -49 -nopervasives -nostdlib -g -I lib/.Typing.objs/byte -I lib/.Typing.objs/native -intf-suffix .ml-gen -no-alias-deps -opaque -o lib/.Typing.objs/native/typing.cmx -c -impl lib/typing.ml-gen)
Done: 100% (2/2, 0 left) (jobs: 0)                                  Done: 28% (10/35, 25 left) (jobs: 1)                                    Running[3]: (cd _build/default && /home/mdupont/.opam/4.14.0/bin/ocamlc.opt -g -w -24 -I .ppx/0c7ad814775fc4bee9b20f76c8a687aa -I /home/mdupont/.opam/4.14.0/lib/ocaml-compiler-libs/common -I /home/mdupont/.opam/4.14.0/lib/ocaml-compiler-libs/shadow -I /home/mdupont/.opam/4.14.0/lib/ocaml/compiler-libs -I /home/mdupont/.opam/4.14.0/lib/ppx_derivers -I /home/mdupont/.opam/4.14.0/lib/ppx_yojson -I /home/mdupont/.opam/4.14.0/lib/ppx_yojson/_lib -I /home/mdupont/.opam/4.14.0/lib/ppxlib -I /home/mdupont/.opam/4.14.0/lib/ppxlib/ast -I /home/mdupont/.opam/4.14.0/lib/ppxlib/astlib -I /home/mdupont/.opam/4.14.0/lib/ppxlib/print_diff -I /home/mdupont/.opam/4.14.0/lib/ppxlib/stdppx -I /home/mdupont/.opam/4.14.0/lib/ppxlib/traverse_builtins -I /home/mdupont/.opam/4.14.0/lib/sexplib0 -I /home/mdupont/.opam/4.14.0/lib/stdlib-shims -no-alias-deps -o .ppx/0c7ad814775fc4bee9b20f76c8a687aa/dune__exe___ppx.cmo -c -impl .ppx/0c7ad814775fc4bee9b20f76c8a687aa/_ppx.ml-gen)
Done: 28% (10/35, 25 left) (jobs: 1)                                    Done: 27% (12/43, 31 left) (jobs: 1)                                    Running[4]: (cd _build/default && /home/mdupont/.opam/4.14.0/bin/ocamlopt.opt -g -w -24 -I .ppx/0c7ad814775fc4bee9b20f76c8a687aa -I /home/mdupont/.opam/4.14.0/lib/ocaml-compiler-libs/common -I /home/mdupont/.opam/4.14.0/lib/ocaml-compiler-libs/shadow -I /home/mdupont/.opam/4.14.0/lib/ocaml/compiler-libs -I /home/mdupont/.opam/4.14.0/lib/ppx_derivers -I /home/mdupont/.opam/4.14.0/lib/ppx_yojson -I /home/mdupont/.opam/4.14.0/lib/ppx_yojson/_lib -I /home/mdupont/.opam/4.14.0/lib/ppxlib -I /home/mdupont/.opam/4.14.0/lib/ppxlib/ast -I /home/mdupont/.opam/4.14.0/lib/ppxlib/astlib -I /home/mdupont/.opam/4.14.0/lib/ppxlib/print_diff -I /home/mdupont/.opam/4.14.0/lib/ppxlib/stdppx -I /home/mdupont/.opam/4.14.0/lib/ppxlib/traverse_builtins -I /home/mdupont/.opam/4.14.0/lib/sexplib0 -I /home/mdupont/.opam/4.14.0/lib/stdlib-shims -intf-suffix .ml-gen -no-alias-deps -o .ppx/0c7ad814775fc4bee9b20f76c8a687aa/dune__exe___ppx.cmx -c -impl .ppx/0c7ad814775fc4bee9b20f76c8a687aa/_ppx.ml-gen)
Done: 27% (12/43, 31 left) (jobs: 1)                                    Running[5]: (cd _build/default && /home/mdupont/.opam/4.14.0/bin/ocamlopt.opt -g -w -24 -o .ppx/0c7ad814775fc4bee9b20f76c8a687aa/ppx.exe /home/mdupont/.opam/4.14.0/lib/ocaml/compiler-libs/ocamlcommon.cmxa /home/mdupont/.opam/4.14.0/lib/ocaml-compiler-libs/common/ocaml_common.cmxa /home/mdupont/.opam/4.14.0/lib/ppxlib/astlib/astlib.cmxa /home/mdupont/.opam/4.14.0/lib/stdlib-shims/stdlib_shims.cmxa /home/mdupont/.opam/4.14.0/lib/ppxlib/ast/ppxlib_ast.cmxa /home/mdupont/.opam/4.14.0/lib/ocaml-compiler-libs/shadow/ocaml_shadow.cmxa /home/mdupont/.opam/4.14.0/lib/ppxlib/print_diff/ppxlib_print_diff.cmxa /home/mdupont/.opam/4.14.0/lib/ppx_derivers/ppx_derivers.cmxa /home/mdupont/.opam/4.14.0/lib/ppxlib/traverse_builtins/ppxlib_traverse_builtins.cmxa /home/mdupont/.opam/4.14.0/lib/sexplib0/sexplib0.cmxa /home/mdupont/.opam/4.14.0/lib/ppxlib/stdppx/stdppx.cmxa /home/mdupont/.opam/4.14.0/lib/ppxlib/ppxlib.cmxa /home/mdupont/.opam/4.14.0/lib/ppx_yojson/_lib/ppx_yojson_lib.cmxa /home/mdupont/.opam/4.14.0/lib/ppx_yojson/ppx_yojson.cmxa .ppx/0c7ad814775fc4bee9b20f76c8a687aa/dune__exe___ppx.cmx)
Done: 27% (12/43, 31 left) (jobs: 1)                                    Done: 32% (14/43, 29 left) (jobs: 1)                                    Running[6]: (cd _build/.sandbox/87fd87d361fd3587ca26da4890b230e7/default && .ppx/0c7ad814775fc4bee9b20f76c8a687aa/ppx.exe --cookie 'library-name="Typing"' -o lib/builtin_attributes.pp.ml --impl lib/builtin_attributes.ml -corrected-suffix .ppx-corrected -diff-cmd - -dump-ast)
Done: 32% (14/43, 29 left) (jobs: 1)                                    Running[7]: (cd _build/.sandbox/943b4fde3d762c3a9d9cfa12b926c31f/default && .ppx/0c7ad814775fc4bee9b20f76c8a687aa/ppx.exe --cookie 'library-name="Typing"' -o lib/shape.pp.ml --impl lib/shape.ml -corrected-suffix .ppx-corrected -diff-cmd - -dump-ast)
Done: 32% (14/43, 29 left) (jobs: 1)                                    Running[8]: (cd _build/.sandbox/b01c904f007cea17898d03ff69cabde4/default && .ppx/0c7ad814775fc4bee9b20f76c8a687aa/ppx.exe --cookie 'library-name="Typing"' -o lib/type_immediacy.pp.ml --impl lib/type_immediacy.ml -corrected-suffix .ppx-corrected -diff-cmd - -dump-ast)
Done: 32% (14/43, 29 left) (jobs: 1)                                    Running[9]: (cd _build/.sandbox/7f08d75cda980197166a6c914c351711/default && .ppx/0c7ad814775fc4bee9b20f76c8a687aa/ppx.exe --cookie 'library-name="Typing"' -o lib/types.pp.ml --impl lib/types.ml -corrected-suffix .ppx-corrected -diff-cmd - -dump-ast)
Done: 32% (14/43, 29 left) (jobs: 1)                                    Running[10]: (cd _build/.sandbox/ccfbfdf51ecb257c501ea09b9581526a/default && .ppx/0c7ad814775fc4bee9b20f76c8a687aa/ppx.exe --cookie 'library-name="Typing"' -o lib/typedtree.pp.ml --impl lib/typedtree.ml -corrected-suffix .ppx-corrected -diff-cmd - -dump-ast)
Done: 32% (14/43, 29 left) (jobs: 1)                                    Done: 34% (15/43, 28 left) (jobs: 5)                                    Running[11]: (cd _build/default && /home/mdupont/.opam/4.14.0/bin/ocamldep.opt -modules -impl lib/type_immediacy.pp.ml) > _build/default/lib/.Typing.objs/typing__Type_immediacy.impl.d
Done: 34% (15/43, 28 left) (jobs: 5)                                    Running[12]: (cd _build/default && /home/mdupont/.opam/4.14.0/bin/ocamldep.opt -modules -impl lib/builtin_attributes.pp.ml) > _build/default/lib/.Typing.objs/typing__Builtin_attributes.impl.d
Done: 34% (15/43, 28 left) (jobs: 5)                                    Running[13]: (cd _build/default && /home/mdupont/.opam/4.14.0/bin/ocamldep.opt -modules -impl lib/shape.pp.ml) > _build/default/lib/.Typing.objs/typing__Shape.impl.d
Done: 34% (15/43, 28 left) (jobs: 5)                                    Running[14]: (cd _build/default && /home/mdupont/.opam/4.14.0/bin/ocamlc.opt -w @1..3@5..28@31..39@43@46..47@49..57@61..62@67@69-40 -strict-sequence -strict-formats -short-paths -keep-locs -warn-error -8-9-26-27-37-34-11-11-32-39 -annot -verbose -dsource -g -bin-annot -I lib/.Typing.objs/byte -I /home/mdupont/.opam/4.14.0/lib/ocaml-compiler-libs/common -I /home/mdupont/.opam/4.14.0/lib/ocaml-compiler-libs/shadow -I /home/mdupont/.opam/4.14.0/lib/ocaml/compiler-libs -I /home/mdupont/.opam/4.14.0/lib/ppx_derivers -I /home/mdupont/.opam/4.14.0/lib/ppxlib -I /home/mdupont/.opam/4.14.0/lib/ppxlib/ast -I /home/mdupont/.opam/4.14.0/lib/ppxlib/astlib -I /home/mdupont/.opam/4.14.0/lib/ppxlib/print_diff -I /home/mdupont/.opam/4.14.0/lib/ppxlib/stdppx -I /home/mdupont/.opam/4.14.0/lib/ppxlib/traverse_builtins -I /home/mdupont/.opam/4.14.0/lib/sexplib0 -I /home/mdupont/.opam/4.14.0/lib/stdlib-shims -no-alias-deps -opaque -open Typing -o lib/.Typing.objs/byte/typing__Builtin_attributes.cmo -c -impl lib/builtin_attributes.pp.ml)
Done: 34% (15/43, 28 left) (jobs: 5)                                    Running[15]: (cd _build/default && /home/mdupont/.opam/4.14.0/bin/ocamldep.opt -modules -impl lib/types.pp.ml) > _build/default/lib/.Typing.objs/typing__Types.impl.d
Done: 34% (15/43, 28 left) (jobs: 5)                                    Running[16]: (cd _build/default && /home/mdupont/.opam/4.14.0/bin/ocamldep.opt -modules -impl lib/typedtree.pp.ml) > _build/default/lib/.Typing.objs/typing__Typedtree.impl.d
Done: 34% (15/43, 28 left) (jobs: 5)                                    Running[17]: (cd _build/default && /home/mdupont/.opam/4.14.0/bin/ocamlc.opt -w @1..3@5..28@31..39@43@46..47@49..57@61..62@67@69-40 -strict-sequence -strict-formats -short-paths -keep-locs -warn-error -8-9-26-27-37-34-11-11-32-39 -annot -verbose -dsource -g -bin-annot -I lib/.Typing.objs/byte -I /home/mdupont/.opam/4.14.0/lib/ocaml-compiler-libs/common -I /home/mdupont/.opam/4.14.0/lib/ocaml-compiler-libs/shadow -I /home/mdupont/.opam/4.14.0/lib/ocaml/compiler-libs -I /home/mdupont/.opam/4.14.0/lib/ppx_derivers -I /home/mdupont/.opam/4.14.0/lib/ppxlib -I /home/mdupont/.opam/4.14.0/lib/ppxlib/ast -I /home/mdupont/.opam/4.14.0/lib/ppxlib/astlib -I /home/mdupont/.opam/4.14.0/lib/ppxlib/print_diff -I /home/mdupont/.opam/4.14.0/lib/ppxlib/stdppx -I /home/mdupont/.opam/4.14.0/lib/ppxlib/traverse_builtins -I /home/mdupont/.opam/4.14.0/lib/sexplib0 -I /home/mdupont/.opam/4.14.0/lib/stdlib-shims -no-alias-deps -opaque -open Typing -o lib/.Typing.objs/byte/typing__Shape.cmo -c -impl lib/shape.pp.ml)
Done: 34% (15/43, 28 left) (jobs: 5)                                    Output[14]:
[@@@ocaml.ppx.context
  {
    tool_name = "ppx_driver";
    include_dirs = [];
    load_path = [];
    open_modules = [];
    for_package = None;
    debug = false;
    use_threads = false;
    use_vmthreads = false;
    recursive_types = false;
    principal = false;
    transparent_modules = false;
    unboxed_types = false;
    unsafe_string = false;
    cookies = [("library-name", "Typing")]
  }]
open Asttypes
open Parsetree
let string_of_cst = function | Pconst_string (s, _, _) -> Some s | _ -> None
let string_of_payload =
  function
  | PStr ({ pstr_desc = Pstr_eval ({ pexp_desc = Pexp_constant c }, _) }::[])
      -> string_of_cst c
  | _ -> None
let string_of_opt_payload p =
  match string_of_payload p with | Some s -> s | None -> ""
let error_of_extension ext =
  let submessage_from main_loc main_txt =
    function
    | {
        pstr_desc = Pstr_extension
          (({ txt = ("ocaml.error" | "error"); loc }, p), _)
        } ->
        (match p with
         | PStr
             ({
                pstr_desc = Pstr_eval
                  ({ pexp_desc = Pexp_constant (Pconst_string (msg, _, _)) },
                   _)
                }::[])
             ->
             {
               Location.loc = loc;
               txt = ((fun ppf -> Format.pp_print_text ppf msg))
             }
         | _ ->
             {
               Location.loc = loc;
               txt =
                 ((fun ppf ->
                     Format.fprintf ppf
                       "Invalid syntax for sub-message of extension '%s'."
                       main_txt))
             })
    | { pstr_desc = Pstr_extension (({ txt; loc }, _), _) } ->
        {
          Location.loc = loc;
          txt =
            ((fun ppf ->
                Format.fprintf ppf "Uninterpreted extension '%s'." txt))
        }
    | _ ->
        {
          Location.loc = main_loc;
          txt =
            ((fun ppf ->
                Format.fprintf ppf
                  "Invalid syntax for sub-message of extension '%s'."
                  main_txt))
        } in
  match ext with
  | ({ txt = ("ocaml.error" | "error" as txt); loc }, p) ->
      (match p with
       | PStr [] -> raise Location.Already_displayed_error
       | PStr
           ({
              pstr_desc = Pstr_eval
                ({ pexp_desc = Pexp_constant (Pconst_string (msg, _, _)) },
                 _)
              }::inner)
           ->
           let sub = List.map (submessage_from loc txt) inner in
           Location.error_of_printer ~loc ~sub Format.pp_print_text msg
       | _ -> Location.errorf ~loc "Invalid syntax for extension '%s'." txt)
  | ({ txt; loc }, _) ->
      Location.errorf ~loc "Uninterpreted extension '%s'." txt
let kind_and_message =
  function
  | PStr
      ({
         pstr_desc = Pstr_eval
           ({
              pexp_desc = Pexp_apply
                ({ pexp_desc = Pexp_ident { txt = Longident.Lident id } },
                 (Nolabel,
                  { pexp_desc = Pexp_constant (Pconst_string (s, _, _)) })::[])
              },
            _)
         }::[])
      -> Some (id, s)
  | PStr
      ({
         pstr_desc = Pstr_eval
           ({ pexp_desc = Pexp_ident { txt = Longident.Lident id } }, _)
         }::[])
      -> Some (id, "")
  | _ -> None
let cat s1 s2 = if s2 = "" then s1 else s1 ^ ("\n" ^ s2)
let alert_attr x =
  match (x.attr_name).txt with
  | "ocaml.deprecated" | "deprecated" ->
      Some (x, "deprecated", (string_of_opt_payload x.attr_payload))
  | "ocaml.alert" | "alert" ->
      (match kind_and_message x.attr_payload with
       | Some (kind, message) -> Some (x, kind, message)
       | None -> None)
  | _ -> None
let alert_attrs l = List.filter_map alert_attr l
let alerts_of_attrs l =
  List.fold_left
    (fun acc ->
       fun (_, kind, message) ->
         let upd =
           function
           | None | Some "" -> Some message
           | Some s -> Some (cat s message) in
         Misc.Stdlib.String.Map.update kind upd acc)
    Misc.Stdlib.String.Map.empty (alert_attrs l)
let check_alerts loc attrs s =
  Misc.Stdlib.String.Map.iter
    (fun kind -> fun message -> Location.alert loc ~kind (cat s message))
    (alerts_of_attrs attrs)
let check_alerts_inclusion ~def  ~use  loc attrs1 attrs2 s =
  let m2 = alerts_of_attrs attrs2 in
  Misc.Stdlib.String.Map.iter
    (fun kind ->
       fun msg ->
         if not (Misc.Stdlib.String.Map.mem kind m2)
         then Location.alert ~def ~use ~kind loc (cat s msg))
    (alerts_of_attrs attrs1)
let rec deprecated_mutable_of_attrs =
  function
  | [] -> None
  | {
      attr_name =
        { txt = ("ocaml.deprecated_mutable" | "deprecated_mutable");_};
      attr_payload = p }::_ -> Some (string_of_opt_payload p)
  | _::tl -> deprecated_mutable_of_attrs tl
let check_deprecated_mutable loc attrs s =
  match deprecated_mutable_of_attrs attrs with
  | None -> ()
  | Some txt ->
      Location.deprecated loc
        (Printf.sprintf "mutating field %s" (cat s txt))
let check_deprecated_mutable_inclusion ~def  ~use  loc attrs1 attrs2 s =
  match ((deprecated_mutable_of_attrs attrs1),
          (deprecated_mutable_of_attrs attrs2))
  with
  | (None, _) | (Some _, Some _) -> ()
  | (Some txt, None) ->
      Location.deprecated ~def ~use loc
        (Printf.sprintf "mutating field %s" (cat s txt))
let rec attrs_of_sig =
  function
  | { psig_desc = Psig_attribute a }::tl -> a :: (attrs_of_sig tl)
  | _ -> []
let alerts_of_sig sg = alerts_of_attrs (attrs_of_sig sg)
let rec attrs_of_str =
  function
  | { pstr_desc = Pstr_attribute a }::tl -> a :: (attrs_of_str tl)
  | _ -> []
let alerts_of_str str = alerts_of_attrs (attrs_of_str str)
let check_no_alert attrs =
  List.iter
    (fun (a, _, _) ->
       Location.prerr_warning a.attr_loc
         (Warnings.Misplaced_attribute ((a.attr_name).txt)))
    (alert_attrs attrs)
let warn_payload loc txt msg =
  Location.prerr_warning loc (Warnings.Attribute_payload (txt, msg))
let warning_attribute ?(ppwarning= true)  =
  let process loc txt errflag payload =
    match string_of_payload payload with
    | Some s ->
        (try
           Option.iter (Location.prerr_alert loc)
             (Warnings.parse_options errflag s)
         with | Arg.Bad msg -> warn_payload loc txt msg)
    | None -> warn_payload loc txt "A single string literal is expected" in
  let process_alert loc txt =
    function
    | PStr
        ({
           pstr_desc = Pstr_eval
             ({ pexp_desc = Pexp_constant (Pconst_string (s, _, _)) }, _)
           }::[])
        ->
        (try Warnings.parse_alert_option s
         with | Arg.Bad msg -> warn_payload loc txt msg)
    | k ->
        (match kind_and_message k with
         | Some ("all", _) ->
             warn_payload loc txt "The alert name 'all' is reserved"
         | Some _ -> ()
         | None -> warn_payload loc txt "Invalid payload") in
  function
  | { attr_name = { txt = ("ocaml.warning" | "warning" as txt);_}; attr_loc;
      attr_payload } -> process attr_loc txt false attr_payload
  | { attr_name = { txt = ("ocaml.warnerror" | "warnerror" as txt);_};
      attr_loc; attr_payload } -> process attr_loc txt true attr_payload
  | { attr_name = { txt = ("ocaml.ppwarning" | "ppwarning");_}; attr_loc = _;
      attr_payload = PStr
        ({
           pstr_desc = Pstr_eval
             ({ pexp_desc = Pexp_constant (Pconst_string (s, _, _)) }, _);
           pstr_loc }::[])
      } when ppwarning ->
      Location.prerr_warning pstr_loc (Warnings.Preprocessor s)
  | { attr_name = { txt = ("ocaml.alert" | "alert" as txt);_}; attr_loc;
      attr_payload } -> process_alert attr_loc txt attr_payload
  | _ -> ()
let warning_scope ?ppwarning  attrs f =
  let prev = Warnings.backup () in
  try
    List.iter (warning_attribute ?ppwarning) (List.rev attrs);
    (let ret = f () in Warnings.restore prev; ret)
  with | exn -> (Warnings.restore prev; raise exn)
let warn_on_literal_pattern =
  List.exists
    (fun a ->
       match (a.attr_name).txt with
       | "ocaml.warn_on_literal_pattern" | "warn_on_literal_pattern" -> true
       | _ -> false)
let explicit_arity =
  List.exists
    (fun a ->
       match (a.attr_name).txt with
       | "ocaml.explicit_arity" | "explicit_arity" -> true
       | _ -> false)
let immediate =
  List.exists
    (fun a ->
       match (a.attr_name).txt with
       | "ocaml.immediate" | "immediate" -> true
       | _ -> false)
let immediate64 =
  List.exists
    (fun a ->
       match (a.attr_name).txt with
       | "ocaml.immediate64" | "immediate64" -> true
       | _ -> false)
let check l a = List.mem (a.attr_name).txt l
let has_unboxed attr = List.exists (check ["ocaml.unboxed"; "unboxed"]) attr
let has_boxed attr = List.exists (check ["ocaml.boxed"; "boxed"]) attr
File "lib/builtin_attributes.ml", line 24, characters 30-57:
24 |   | PStr[{pstr_desc=Pstr_eval({pexp_desc=Pexp_constant c},_)}] ->
                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
pexp_loc, pexp_loc_stack, pexp_attributes
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", line 24, characters 9-61:
24 |   | PStr[{pstr_desc=Pstr_eval({pexp_desc=Pexp_constant c},_)}] ->
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
pstr_loc
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", lines 35-36, characters 6-58:
35 | ......{pstr_desc=Pstr_extension
36 |            (({txt = ("ocaml.error"|"error"); loc}, p), _)}...
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
pstr_loc
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", line 47, characters 6-53:
47 |     | {pstr_desc=Pstr_extension (({txt; loc}, _), _)} ->
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
pstr_loc
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", line 39, characters 22-71:
39 |                      ({pexp_desc=Pexp_constant(Pconst_string(msg,_,_))}, _)}
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
pexp_loc, pexp_loc_stack, pexp_attributes
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", lines 38-39, characters 16-76:
38 | ................{pstr_desc=Pstr_eval
39 |                      ({pexp_desc=Pexp_constant(Pconst_string(msg,_,_))}, _)}
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
pstr_loc
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", line 60, characters 19-68:
60 |                   ({pexp_desc=Pexp_constant(Pconst_string(msg,_,_))}, _)}::
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
pexp_loc, pexp_loc_stack, pexp_attributes
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", lines 59-60, characters 13-73:
59 | .............{pstr_desc=Pstr_eval
60 |                   ({pexp_desc=Pexp_constant(Pconst_string(msg,_,_))}, _)}..
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
pstr_loc
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", line 75, characters 39-64:
75 |                  ({pexp_desc=Pexp_ident{txt=Longident.Lident id}},
                                            ^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
loc
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", line 75, characters 18-65:
75 |                  ({pexp_desc=Pexp_ident{txt=Longident.Lident id}},
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
pexp_loc, pexp_loc_stack, pexp_attributes
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", line 76, characters 27-75:
76 |                   [Nolabel,{pexp_desc=Pexp_constant (Pconst_string(s,_,_))}])
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
pexp_loc, pexp_loc_stack, pexp_attributes
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", lines 74-77, characters 12-13:
74 | ............{pexp_desc=Pexp_apply
75 |                  ({pexp_desc=Pexp_ident{txt=Longident.Lident id}},
76 |                   [Nolabel,{pexp_desc=Pexp_constant (Pconst_string(s,_,_))}])
77 |             }........
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
pexp_loc, pexp_loc_stack, pexp_attributes
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", lines 72-77, characters 6-17:
72 | ......{pstr_desc=
73 |          Pstr_eval
74 |            ({pexp_desc=Pexp_apply
75 |                  ({pexp_desc=Pexp_ident{txt=Longident.Lident id}},
76 |                   [Nolabel,{pexp_desc=Pexp_constant (Pconst_string(s,_,_))}])
77 |             },_)}....
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
pstr_loc
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", line 82, characters 33-58:
82 |            ({pexp_desc=Pexp_ident{txt=Longident.Lident id}},_)}] ->
                                      ^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
loc
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", line 82, characters 12-59:
82 |            ({pexp_desc=Pexp_ident{txt=Longident.Lident id}},_)}] ->
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
pexp_loc, pexp_loc_stack, pexp_attributes
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", lines 80-82, characters 6-63:
80 | ......{pstr_desc=
81 |          Pstr_eval
82 |            ({pexp_desc=Pexp_ident{txt=Longident.Lident id}},_)}....
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
pstr_loc
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", lines 131-132, characters 4-22:
131 | ....{attr_name =  {txt = "ocaml.deprecated_mutable"|"deprecated_mutable"; _};
132 |      attr_payload = p}........
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
attr_loc
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", line 152, characters 4-34:
152 |   | {psig_desc = Psig_attribute a} :: tl ->
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
psig_loc
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", line 160, characters 4-34:
160 |   | {pstr_desc = Pstr_attribute a} :: tl ->
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
pstr_loc
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", line 193, characters 16-63:
193 |                 {pexp_desc=Pexp_constant(Pconst_string(s,_,_))},
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
pexp_loc, pexp_loc_stack, pexp_attributes
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", lines 191-195, characters 11-12:
191 | ...........{pstr_desc=
192 |               Pstr_eval(
193 |                 {pexp_desc=Pexp_constant(Pconst_string(s,_,_))},
194 |                 _)
195 |            }....
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
pstr_loc
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", line 222, characters 23-74:
222 |              Pstr_eval({pexp_desc=Pexp_constant (Pconst_string (s, _, _))},_);
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
pexp_loc, pexp_loc_stack, pexp_attributes
Either bind these labels explicitly or add '; _' to the pattern.
Done: 34% (15/43, 28 left) (jobs: 5)                                    Running[18]: (cd _build/default && /home/mdupont/.opam/4.14.0/bin/ocamlopt.opt -w @1..3@5..28@31..39@43@46..47@49..57@61..62@67@69-40 -strict-sequence -strict-formats -short-paths -keep-locs -warn-error -8-9-26-27-37-34-11-11-32-39 -annot -verbose -dsource -g -I lib/.Typing.objs/byte -I lib/.Typing.objs/native -I /home/mdupont/.opam/4.14.0/lib/ocaml-compiler-libs/common -I /home/mdupont/.opam/4.14.0/lib/ocaml-compiler-libs/shadow -I /home/mdupont/.opam/4.14.0/lib/ocaml/compiler-libs -I /home/mdupont/.opam/4.14.0/lib/ppx_derivers -I /home/mdupont/.opam/4.14.0/lib/ppxlib -I /home/mdupont/.opam/4.14.0/lib/ppxlib/ast -I /home/mdupont/.opam/4.14.0/lib/ppxlib/astlib -I /home/mdupont/.opam/4.14.0/lib/ppxlib/print_diff -I /home/mdupont/.opam/4.14.0/lib/ppxlib/stdppx -I /home/mdupont/.opam/4.14.0/lib/ppxlib/traverse_builtins -I /home/mdupont/.opam/4.14.0/lib/sexplib0 -I /home/mdupont/.opam/4.14.0/lib/stdlib-shims -intf-suffix .ml -no-alias-deps -opaque -open Typing -o lib/.Typing.objs/native/typing__Builtin_attributes.cmx -c -impl lib/builtin_attributes.pp.ml)
Done: 34% (15/43, 28 left) (jobs: 5)                                    Running[19]: (cd _build/default && /home/mdupont/.opam/4.14.0/bin/ocamlc.opt -w @1..3@5..28@31..39@43@46..47@49..57@61..62@67@69-40 -strict-sequence -strict-formats -short-paths -keep-locs -warn-error -8-9-26-27-37-34-11-11-32-39 -annot -verbose -dsource -g -bin-annot -I lib/.Typing.objs/byte -I /home/mdupont/.opam/4.14.0/lib/ocaml-compiler-libs/common -I /home/mdupont/.opam/4.14.0/lib/ocaml-compiler-libs/shadow -I /home/mdupont/.opam/4.14.0/lib/ocaml/compiler-libs -I /home/mdupont/.opam/4.14.0/lib/ppx_derivers -I /home/mdupont/.opam/4.14.0/lib/ppxlib -I /home/mdupont/.opam/4.14.0/lib/ppxlib/ast -I /home/mdupont/.opam/4.14.0/lib/ppxlib/astlib -I /home/mdupont/.opam/4.14.0/lib/ppxlib/print_diff -I /home/mdupont/.opam/4.14.0/lib/ppxlib/stdppx -I /home/mdupont/.opam/4.14.0/lib/ppxlib/traverse_builtins -I /home/mdupont/.opam/4.14.0/lib/sexplib0 -I /home/mdupont/.opam/4.14.0/lib/stdlib-shims -no-alias-deps -opaque -open Typing -o lib/.Typing.objs/byte/typing__Type_immediacy.cmo -c -impl lib/type_immediacy.pp.ml)
Done: 34% (15/43, 28 left) (jobs: 5)                                    Output[17]:
[@@@ocaml.ppx.context
  {
    tool_name = "ppx_driver";
    include_dirs = [];
    load_path = [];
    open_modules = [];
    for_package = None;
    debug = false;
    use_threads = false;
    use_vmthreads = false;
    recursive_types = false;
    principal = false;
    transparent_modules = false;
    unboxed_types = false;
    unsafe_string = false;
    cookies = [("library-name", "Typing")]
  }]
module Uid =
  struct
    type t =
      | Compilation_unit of string 
      | Item of {
      comp_unit: string ;
      id: int } 
      | Internal 
      | Predef of string 
    include
      (Identifiable.Make)(struct
                            type nonrec t = t
                            let equal (x : t) y = x = y
                            let compare (x : t) y = compare x y
                            let hash (x : t) = Hashtbl.hash x
                            let print fmt =
                              function
                              | Internal ->
                                  Format.pp_print_string fmt "<internal>"
                              | Predef name ->
                                  Format.fprintf fmt "<predef:%s>" name
                              | Compilation_unit s ->
                                  Format.pp_print_string fmt s
                              | Item { comp_unit; id } ->
                                  Format.fprintf fmt "%s.%d" comp_unit id
                            let output oc t =
                              let fmt = Format.formatter_of_out_channel oc in
                              print fmt t
                          end)
    let id = ref (-1)
    let reinit () = id := (-1)
    let mk ~current_unit  =
      incr id; Item { comp_unit = current_unit; id = (!id) }
    let of_compilation_unit_id id =
      if not (Ident.persistent id)
      then
        Misc.fatal_errorf "Types.Uid.of_compilation_unit_id %S"
          (Ident.name id);
      Compilation_unit (Ident.name id)
    let of_predef_id id =
      if not (Ident.is_predef id)
      then Misc.fatal_errorf "Types.Uid.of_predef_id %S" (Ident.name id);
      Predef (Ident.name id)
    let internal_not_actually_unique = Internal
    let for_actual_declaration = function | Item _ -> true | _ -> false
  end
module Sig_component_kind =
  struct
    type t =
      | Value 
      | Type 
      | Module 
      | Module_type 
      | Extension_constructor 
      | Class 
      | Class_type 
    let to_string =
      function
      | Value -> "value"
      | Type -> "type"
      | Module -> "module"
      | Module_type -> "module type"
      | Extension_constructor -> "extension constructor"
      | Class -> "class"
      | Class_type -> "class type"
    let can_appear_in_types =
      function
      | Value | Extension_constructor -> false
      | Type | Module | Module_type | Class | Class_type -> true
  end
module Item =
  struct
    module T =
      struct
        type t = (string * Sig_component_kind.t)
        let compare = compare
        let make str ns = (str, ns)
        let value id = ((Ident.name id), Sig_component_kind.Value)
        let type_ id = ((Ident.name id), Sig_component_kind.Type)
        let module_ id = ((Ident.name id), Sig_component_kind.Module)
        let module_type id =
          ((Ident.name id), Sig_component_kind.Module_type)
        let extension_constructor id =
          ((Ident.name id), Sig_component_kind.Extension_constructor)
        let class_ id = ((Ident.name id), Sig_component_kind.Class)
        let class_type id = ((Ident.name id), Sig_component_kind.Class_type)
        let print fmt (name, ns) =
          Format.fprintf fmt "%S[%s]" name (Sig_component_kind.to_string ns)
      end
    include T
    module Map = (Map.Make)(T)
  end
type var = Ident.t
type t = {
  uid: Uid.t option ;
  desc: desc }
and desc =
  | Var of var 
  | Abs of var * t 
  | App of t * t 
  | Struct of t Item.Map.t 
  | Leaf 
  | Proj of t * Item.t 
  | Comp_unit of string 
let print fmt =
  let print_uid_opt =
    Format.pp_print_option (fun fmt -> Format.fprintf fmt "<%a>" Uid.print) in
  let rec aux fmt { uid; desc } =
    match desc with
    | Var id -> Format.fprintf fmt "%a%a" Ident.print id print_uid_opt uid
    | Abs (id, t) ->
        Format.fprintf fmt "Abs@[%a@,(@[%a,@ @[%a@]@])@]" print_uid_opt uid
          Ident.print id aux t
    | App (t1, t2) ->
        Format.fprintf fmt "@[%a(@,%a)%a@]" aux t1 aux t2 print_uid_opt uid
    | Leaf ->
        Format.fprintf fmt "<%a>" (Format.pp_print_option Uid.print) uid
    | Proj (t, item) ->
        (match uid with
         | None -> Format.fprintf fmt "@[%a@ .@ %a@]" aux t Item.print item
         | Some uid ->
             Format.fprintf fmt "@[(%a@ .@ %a)<%a>@]" aux t Item.print item
               Uid.print uid)
    | Comp_unit name -> Format.fprintf fmt "CU %s" name
    | Struct map ->
        let print_map fmt =
          Item.Map.iter
            (fun item ->
               fun t ->
                 Format.fprintf fmt "@[<hv 4>%a ->@ %a;@]@," Item.print item
                   aux t) in
        Format.fprintf fmt "{@[<v>%a@,%a@]}" print_uid_opt uid print_map map in
  Format.fprintf fmt "@[%a@]@;" aux
let fresh_var ?(name= "shape-var")  uid =
  let var = Ident.create_local name in
  (var, { uid = (Some uid); desc = (Var var) })
let for_unnamed_functor_param = Ident.create_local "()"
let var uid id = { uid = (Some uid); desc = (Var id) }
let abs ?uid  var body = { uid; desc = (Abs (var, body)) }
let str ?uid  map = { uid; desc = (Struct map) }
let leaf uid = { uid = (Some uid); desc = Leaf }
let proj ?uid  t item =
  match t.desc with
  | Leaf -> t
  | Struct map -> (try Item.Map.find item map with | Not_found -> t)
  | _ -> { uid; desc = (Proj (t, item)) }
let app ?uid  f ~arg  = { uid; desc = (App (f, arg)) }
let decompose_abs t =
  match t.desc with | Abs (x, t) -> Some (x, t) | _ -> None
module Make_reduce(Params:sig
                            type env
                            val fuel : int
                            val read_unit_shape :
                              unit_name:string -> t option
                            val find_shape : env -> Ident.t -> t
                          end) =
  struct
    type nf = {
      uid: Uid.t option ;
      desc: nf_desc }
    and nf_desc =
      | NVar of var 
      | NApp of nf * nf 
      | NAbs of local_env * var * t * delayed_nf 
      | NStruct of delayed_nf Item.Map.t 
      | NProj of nf * Item.t 
      | NLeaf 
      | NComp_unit of string 
      | NoFuelLeft of desc 
    and delayed_nf =
      | Thunk of local_env * t 
    and local_env = delayed_nf option Ident.Map.t
    let improve_uid uid (nf : nf) =
      match nf.uid with | Some _ -> nf | None -> { nf with uid }
    let in_memo_table memo_table memo_key f arg =
      match Hashtbl.find memo_table memo_key with
      | res -> res
      | exception Not_found ->
          let res = f arg in (Hashtbl.replace memo_table memo_key res; res)
    type env =
      {
      fuel: int ref ;
      global_env: Params.env ;
      local_env: local_env ;
      reduce_memo_table: ((local_env * t), nf) Hashtbl.t ;
      read_back_memo_table: (nf, t) Hashtbl.t }
    let bind env var shape =
      { env with local_env = (Ident.Map.add var shape env.local_env) }
    let rec reduce_ env t =
      let memo_key = ((env.local_env), t) in
      in_memo_table env.reduce_memo_table memo_key (reduce__ env) t
    and reduce__ ({ fuel; global_env; local_env;_} as env) (t : t) =
      let reduce env t = reduce_ env t in
      let delay_reduce env t = Thunk ((env.local_env), t) in
      let force (Thunk (local_env, t)) = reduce { env with local_env } t in
      let return desc = ({ uid = (t.uid); desc } : nf) in
      if (!fuel) < 0
      then return (NoFuelLeft (t.desc))
      else
        (match t.desc with
         | Comp_unit unit_name ->
             (match Params.read_unit_shape ~unit_name with
              | Some t -> reduce env t
              | None -> return (NComp_unit unit_name))
         | App (f, arg) ->
             let f = reduce env f in
             (match f.desc with
              | NAbs (clos_env, var, body, _body_nf) ->
                  let arg = delay_reduce env arg in
                  let env =
                    bind { env with local_env = clos_env } var (Some arg) in
                  (reduce env body) |> (improve_uid t.uid)
              | _ -> let arg = reduce env arg in return (NApp (f, arg)))
         | Proj (str, item) ->
             let str = reduce env str in
             let nored () = return (NProj (str, item)) in
             (match str.desc with
              | NStruct items ->
                  (match Item.Map.find item items with
                   | exception Not_found -> nored ()
                   | nf -> (force nf) |> (improve_uid t.uid))
              | _ -> nored ())
         | Abs (var, body) ->
             let body_nf = delay_reduce (bind env var None) body in
             return (NAbs (local_env, var, body, body_nf))
         | Var id ->
             (match Ident.Map.find id local_env with
              | None -> return (NVar id)
              | Some def -> force def
              | exception Not_found ->
                  (match Params.find_shape global_env id with
                   | exception Not_found -> return (NVar id)
                   | res when res = t -> return (NVar id)
                   | res -> (decr fuel; reduce env res)))
         | Leaf -> return NLeaf
         | Struct m ->
             let mnf = Item.Map.map (delay_reduce env) m in
             return (NStruct mnf))
    let rec read_back env (nf : nf) =
      (in_memo_table env.read_back_memo_table nf (read_back_ env) nf : 
      t)
    and read_back_ env (nf : nf) =
      ({ uid = (nf.uid); desc = (read_back_desc env nf.desc) } : t)
    and read_back_desc env desc =
      let read_back nf = read_back env nf in
      let read_back_force (Thunk (local_env, t)) =
        read_back (reduce_ { env with local_env } t) in
      match desc with
      | NVar v -> Var v
      | NApp (nft, nfu) -> App ((read_back nft), (read_back nfu))
      | NAbs (_env, x, _t, nf) -> Abs (x, (read_back_force nf))
      | NStruct nstr -> Struct (Item.Map.map read_back_force nstr)
      | NProj (nf, item) -> Proj ((read_back nf), item)
      | NLeaf -> Leaf
      | NComp_unit s -> Comp_unit s
      | NoFuelLeft t -> t
    let reduce global_env t =
      let fuel = ref Params.fuel in
      let reduce_memo_table = Hashtbl.create 42 in
      let read_back_memo_table = Hashtbl.create 42 in
      let local_env = Ident.Map.empty in
      let env =
        {
          fuel;
          global_env;
          reduce_memo_table;
          read_back_memo_table;
          local_env
        } in
      (reduce_ env t) |> (read_back env)
  end
module Local_reduce =
  (Make_reduce)(struct
                  type env = unit
                  let fuel = 10
                  let read_unit_shape ~unit_name:_  = None
                  let find_shape _env _id = raise Not_found
                end)
let local_reduce shape = Local_reduce.reduce () shape
let dummy_mod = { uid = None; desc = (Struct Item.Map.empty) }
let of_path ~find_shape  ~namespace  =
  let rec aux : Sig_component_kind.t -> Path.t -> t =
    fun ns ->
      function
      | Pident id -> find_shape ns id
      | Pdot (path, name) -> proj (aux Module path) (name, ns)
      | Papply (p1, p2) -> app (aux Module p1) ~arg:(aux Module p2) in
  aux namespace
let for_persistent_unit s =
  {
    uid = (Some (Uid.of_compilation_unit_id (Ident.create_persistent s)));
    desc = (Comp_unit s)
  }
let leaf_for_unpack = { uid = None; desc = Leaf }
let set_uid_if_none t uid =
  match t.uid with | None -> { t with uid = (Some uid) } | _ -> t
module Map =
  struct
    type shape = t
    type nonrec t = t Item.Map.t
    let empty = Item.Map.empty
    let add t item shape = Item.Map.add item shape t
    let add_value t id uid = Item.Map.add (Item.value id) (leaf uid) t
    let add_value_proj t id shape =
      let item = Item.value id in Item.Map.add item (proj shape item) t
    let add_type t id uid = Item.Map.add (Item.type_ id) (leaf uid) t
    let add_type_proj t id shape =
      let item = Item.type_ id in Item.Map.add item (proj shape item) t
    let add_module t id shape = Item.Map.add (Item.module_ id) shape t
    let add_module_proj t id shape =
      let item = Item.module_ id in Item.Map.add item (proj shape item) t
    let add_module_type t id uid =
      Item.Map.add (Item.module_type id) (leaf uid) t
    let add_module_type_proj t id shape =
      let item = Item.module_type id in Item.Map.add item (proj shape item) t
    let add_extcons t id uid =
      Item.Map.add (Item.extension_constructor id) (leaf uid) t
    let add_extcons_proj t id shape =
      let item = Item.extension_constructor id in
      Item.Map.add item (proj shape item) t
    let add_class t id uid = Item.Map.add (Item.class_ id) (leaf uid) t
    let add_class_proj t id shape =
      let item = Item.class_ id in Item.Map.add item (proj shape item) t
    let add_class_type t id uid =
      Item.Map.add (Item.class_type id) (leaf uid) t
    let add_class_type_proj t id shape =
      let item = Item.class_type id in Item.Map.add item (proj shape item) t
  end
Done: 34% (15/43, 28 left) (jobs: 5)                                    Running[20]: (cd _build/default && /home/mdupont/.opam/4.14.0/bin/ocamlopt.opt -w @1..3@5..28@31..39@43@46..47@49..57@61..62@67@69-40 -strict-sequence -strict-formats -short-paths -keep-locs -warn-error -8-9-26-27-37-34-11-11-32-39 -annot -verbose -dsource -g -I lib/.Typing.objs/byte -I lib/.Typing.objs/native -I /home/mdupont/.opam/4.14.0/lib/ocaml-compiler-libs/common -I /home/mdupont/.opam/4.14.0/lib/ocaml-compiler-libs/shadow -I /home/mdupont/.opam/4.14.0/lib/ocaml/compiler-libs -I /home/mdupont/.opam/4.14.0/lib/ppx_derivers -I /home/mdupont/.opam/4.14.0/lib/ppxlib -I /home/mdupont/.opam/4.14.0/lib/ppxlib/ast -I /home/mdupont/.opam/4.14.0/lib/ppxlib/astlib -I /home/mdupont/.opam/4.14.0/lib/ppxlib/print_diff -I /home/mdupont/.opam/4.14.0/lib/ppxlib/stdppx -I /home/mdupont/.opam/4.14.0/lib/ppxlib/traverse_builtins -I /home/mdupont/.opam/4.14.0/lib/sexplib0 -I /home/mdupont/.opam/4.14.0/lib/stdlib-shims -intf-suffix .ml -no-alias-deps -opaque -open Typing -o lib/.Typing.objs/native/typing__Shape.cmx -c -impl lib/shape.pp.ml)
Done: 34% (15/43, 28 left) (jobs: 5)                                    Done: 74% (32/43, 11 left) (jobs: 3)                                    Output[19]:
[@@@ocaml.ppx.context
  {
    tool_name = "ppx_driver";
    include_dirs = [];
    load_path = [];
    open_modules = [];
    for_package = None;
    debug = false;
    use_threads = false;
    use_vmthreads = false;
    recursive_types = false;
    principal = false;
    transparent_modules = false;
    unboxed_types = false;
    unsafe_string = false;
    cookies = [("library-name", "Typing")]
  }]
type t =
  | Unknown 
  | Always 
  | Always_on_64bits 
module Violation =
  struct type t =
           | Not_always_immediate 
           | Not_always_immediate_on_64bits  end
let coerce t ~as_  =
  match (t, as_) with
  | (_, Unknown) | (Always, Always)
    | ((Always | Always_on_64bits), Always_on_64bits) -> Ok ()
  | ((Unknown | Always_on_64bits), Always) ->
      Error Violation.Not_always_immediate
  | (Unknown, Always_on_64bits) ->
      Error Violation.Not_always_immediate_on_64bits
let of_attributes attrs =
  match ((Builtin_attributes.immediate attrs),
          (Builtin_attributes.immediate64 attrs))
  with
  | (true, _) -> Always
  | (false, true) -> Always_on_64bits
  | (false, false) -> Unknown
Done: 74% (32/43, 11 left) (jobs: 3)                                    Running[21]: (cd _build/default && /home/mdupont/.opam/4.14.0/bin/ocamlopt.opt -w @1..3@5..28@31..39@43@46..47@49..57@61..62@67@69-40 -strict-sequence -strict-formats -short-paths -keep-locs -warn-error -8-9-26-27-37-34-11-11-32-39 -annot -verbose -dsource -g -I lib/.Typing.objs/byte -I lib/.Typing.objs/native -I /home/mdupont/.opam/4.14.0/lib/ocaml-compiler-libs/common -I /home/mdupont/.opam/4.14.0/lib/ocaml-compiler-libs/shadow -I /home/mdupont/.opam/4.14.0/lib/ocaml/compiler-libs -I /home/mdupont/.opam/4.14.0/lib/ppx_derivers -I /home/mdupont/.opam/4.14.0/lib/ppxlib -I /home/mdupont/.opam/4.14.0/lib/ppxlib/ast -I /home/mdupont/.opam/4.14.0/lib/ppxlib/astlib -I /home/mdupont/.opam/4.14.0/lib/ppxlib/print_diff -I /home/mdupont/.opam/4.14.0/lib/ppxlib/stdppx -I /home/mdupont/.opam/4.14.0/lib/ppxlib/traverse_builtins -I /home/mdupont/.opam/4.14.0/lib/sexplib0 -I /home/mdupont/.opam/4.14.0/lib/stdlib-shims -intf-suffix .ml -no-alias-deps -opaque -open Typing -o lib/.Typing.objs/native/typing__Type_immediacy.cmx -c -impl lib/type_immediacy.pp.ml)
Done: 74% (32/43, 11 left) (jobs: 3)                                    Running[22]: (cd _build/default && /home/mdupont/.opam/4.14.0/bin/ocamlc.opt -w @1..3@5..28@31..39@43@46..47@49..57@61..62@67@69-40 -strict-sequence -strict-formats -short-paths -keep-locs -warn-error -8-9-26-27-37-34-11-11-32-39 -annot -verbose -dsource -g -bin-annot -I lib/.Typing.objs/byte -I /home/mdupont/.opam/4.14.0/lib/ocaml-compiler-libs/common -I /home/mdupont/.opam/4.14.0/lib/ocaml-compiler-libs/shadow -I /home/mdupont/.opam/4.14.0/lib/ocaml/compiler-libs -I /home/mdupont/.opam/4.14.0/lib/ppx_derivers -I /home/mdupont/.opam/4.14.0/lib/ppxlib -I /home/mdupont/.opam/4.14.0/lib/ppxlib/ast -I /home/mdupont/.opam/4.14.0/lib/ppxlib/astlib -I /home/mdupont/.opam/4.14.0/lib/ppxlib/print_diff -I /home/mdupont/.opam/4.14.0/lib/ppxlib/stdppx -I /home/mdupont/.opam/4.14.0/lib/ppxlib/traverse_builtins -I /home/mdupont/.opam/4.14.0/lib/sexplib0 -I /home/mdupont/.opam/4.14.0/lib/stdlib-shims -no-alias-deps -opaque -open Typing -o lib/.Typing.objs/byte/typing__Types.cmo -c -impl lib/types.pp.ml)
Done: 74% (32/43, 11 left) (jobs: 3)                                    Output[21]:
[@@@ocaml.ppx.context
  {
    tool_name = "ppx_driver";
    include_dirs = [];
    load_path = [];
    open_modules = [];
    for_package = None;
    debug = false;
    use_threads = false;
    use_vmthreads = false;
    recursive_types = false;
    principal = false;
    transparent_modules = false;
    unboxed_types = false;
    unsafe_string = false;
    cookies = [("library-name", "Typing")]
  }]
type t =
  | Unknown 
  | Always 
  | Always_on_64bits 
module Violation =
  struct type t =
           | Not_always_immediate 
           | Not_always_immediate_on_64bits  end
let coerce t ~as_  =
  match (t, as_) with
  | (_, Unknown) | (Always, Always)
    | ((Always | Always_on_64bits), Always_on_64bits) -> Ok ()
  | ((Unknown | Always_on_64bits), Always) ->
      Error Violation.Not_always_immediate
  | (Unknown, Always_on_64bits) ->
      Error Violation.Not_always_immediate_on_64bits
let of_attributes attrs =
  match ((Builtin_attributes.immediate attrs),
          (Builtin_attributes.immediate64 attrs))
  with
  | (true, _) -> Always
  | (false, true) -> Always_on_64bits
  | (false, false) -> Unknown
+ as --debug-prefix-map '/mnt/data1/nix/time/2024/08/12/ocaml_introspector/_build/default'='/workspace_root' -o 'lib/.Typing.objs/native/typing__Type_immediacy.o' '/tmp/build_9dd4b3_dune/camlasm7ca798.s'
Done: 74% (32/43, 11 left) (jobs: 3)                                    Output[18]:
[@@@ocaml.ppx.context
  {
    tool_name = "ppx_driver";
    include_dirs = [];
    load_path = [];
    open_modules = [];
    for_package = None;
    debug = false;
    use_threads = false;
    use_vmthreads = false;
    recursive_types = false;
    principal = false;
    transparent_modules = false;
    unboxed_types = false;
    unsafe_string = false;
    cookies = [("library-name", "Typing")]
  }]
open Asttypes
open Parsetree
let string_of_cst = function | Pconst_string (s, _, _) -> Some s | _ -> None
let string_of_payload =
  function
  | PStr ({ pstr_desc = Pstr_eval ({ pexp_desc = Pexp_constant c }, _) }::[])
      -> string_of_cst c
  | _ -> None
let string_of_opt_payload p =
  match string_of_payload p with | Some s -> s | None -> ""
let error_of_extension ext =
  let submessage_from main_loc main_txt =
    function
    | {
        pstr_desc = Pstr_extension
          (({ txt = ("ocaml.error" | "error"); loc }, p), _)
        } ->
        (match p with
         | PStr
             ({
                pstr_desc = Pstr_eval
                  ({ pexp_desc = Pexp_constant (Pconst_string (msg, _, _)) },
                   _)
                }::[])
             ->
             {
               Location.loc = loc;
               txt = ((fun ppf -> Format.pp_print_text ppf msg))
             }
         | _ ->
             {
               Location.loc = loc;
               txt =
                 ((fun ppf ->
                     Format.fprintf ppf
                       "Invalid syntax for sub-message of extension '%s'."
                       main_txt))
             })
    | { pstr_desc = Pstr_extension (({ txt; loc }, _), _) } ->
        {
          Location.loc = loc;
          txt =
            ((fun ppf ->
                Format.fprintf ppf "Uninterpreted extension '%s'." txt))
        }
    | _ ->
        {
          Location.loc = main_loc;
          txt =
            ((fun ppf ->
                Format.fprintf ppf
                  "Invalid syntax for sub-message of extension '%s'."
                  main_txt))
        } in
  match ext with
  | ({ txt = ("ocaml.error" | "error" as txt); loc }, p) ->
      (match p with
       | PStr [] -> raise Location.Already_displayed_error
       | PStr
           ({
              pstr_desc = Pstr_eval
                ({ pexp_desc = Pexp_constant (Pconst_string (msg, _, _)) },
                 _)
              }::inner)
           ->
           let sub = List.map (submessage_from loc txt) inner in
           Location.error_of_printer ~loc ~sub Format.pp_print_text msg
       | _ -> Location.errorf ~loc "Invalid syntax for extension '%s'." txt)
  | ({ txt; loc }, _) ->
      Location.errorf ~loc "Uninterpreted extension '%s'." txt
let kind_and_message =
  function
  | PStr
      ({
         pstr_desc = Pstr_eval
           ({
              pexp_desc = Pexp_apply
                ({ pexp_desc = Pexp_ident { txt = Longident.Lident id } },
                 (Nolabel,
                  { pexp_desc = Pexp_constant (Pconst_string (s, _, _)) })::[])
              },
            _)
         }::[])
      -> Some (id, s)
  | PStr
      ({
         pstr_desc = Pstr_eval
           ({ pexp_desc = Pexp_ident { txt = Longident.Lident id } }, _)
         }::[])
      -> Some (id, "")
  | _ -> None
let cat s1 s2 = if s2 = "" then s1 else s1 ^ ("\n" ^ s2)
let alert_attr x =
  match (x.attr_name).txt with
  | "ocaml.deprecated" | "deprecated" ->
      Some (x, "deprecated", (string_of_opt_payload x.attr_payload))
  | "ocaml.alert" | "alert" ->
      (match kind_and_message x.attr_payload with
       | Some (kind, message) -> Some (x, kind, message)
       | None -> None)
  | _ -> None
let alert_attrs l = List.filter_map alert_attr l
let alerts_of_attrs l =
  List.fold_left
    (fun acc ->
       fun (_, kind, message) ->
         let upd =
           function
           | None | Some "" -> Some message
           | Some s -> Some (cat s message) in
         Misc.Stdlib.String.Map.update kind upd acc)
    Misc.Stdlib.String.Map.empty (alert_attrs l)
let check_alerts loc attrs s =
  Misc.Stdlib.String.Map.iter
    (fun kind -> fun message -> Location.alert loc ~kind (cat s message))
    (alerts_of_attrs attrs)
let check_alerts_inclusion ~def  ~use  loc attrs1 attrs2 s =
  let m2 = alerts_of_attrs attrs2 in
  Misc.Stdlib.String.Map.iter
    (fun kind ->
       fun msg ->
         if not (Misc.Stdlib.String.Map.mem kind m2)
         then Location.alert ~def ~use ~kind loc (cat s msg))
    (alerts_of_attrs attrs1)
let rec deprecated_mutable_of_attrs =
  function
  | [] -> None
  | {
      attr_name =
        { txt = ("ocaml.deprecated_mutable" | "deprecated_mutable");_};
      attr_payload = p }::_ -> Some (string_of_opt_payload p)
  | _::tl -> deprecated_mutable_of_attrs tl
let check_deprecated_mutable loc attrs s =
  match deprecated_mutable_of_attrs attrs with
  | None -> ()
  | Some txt ->
      Location.deprecated loc
        (Printf.sprintf "mutating field %s" (cat s txt))
let check_deprecated_mutable_inclusion ~def  ~use  loc attrs1 attrs2 s =
  match ((deprecated_mutable_of_attrs attrs1),
          (deprecated_mutable_of_attrs attrs2))
  with
  | (None, _) | (Some _, Some _) -> ()
  | (Some txt, None) ->
      Location.deprecated ~def ~use loc
        (Printf.sprintf "mutating field %s" (cat s txt))
let rec attrs_of_sig =
  function
  | { psig_desc = Psig_attribute a }::tl -> a :: (attrs_of_sig tl)
  | _ -> []
let alerts_of_sig sg = alerts_of_attrs (attrs_of_sig sg)
let rec attrs_of_str =
  function
  | { pstr_desc = Pstr_attribute a }::tl -> a :: (attrs_of_str tl)
  | _ -> []
let alerts_of_str str = alerts_of_attrs (attrs_of_str str)
let check_no_alert attrs =
  List.iter
    (fun (a, _, _) ->
       Location.prerr_warning a.attr_loc
         (Warnings.Misplaced_attribute ((a.attr_name).txt)))
    (alert_attrs attrs)
let warn_payload loc txt msg =
  Location.prerr_warning loc (Warnings.Attribute_payload (txt, msg))
let warning_attribute ?(ppwarning= true)  =
  let process loc txt errflag payload =
    match string_of_payload payload with
    | Some s ->
        (try
           Option.iter (Location.prerr_alert loc)
             (Warnings.parse_options errflag s)
         with | Arg.Bad msg -> warn_payload loc txt msg)
    | None -> warn_payload loc txt "A single string literal is expected" in
  let process_alert loc txt =
    function
    | PStr
        ({
           pstr_desc = Pstr_eval
             ({ pexp_desc = Pexp_constant (Pconst_string (s, _, _)) }, _)
           }::[])
        ->
        (try Warnings.parse_alert_option s
         with | Arg.Bad msg -> warn_payload loc txt msg)
    | k ->
        (match kind_and_message k with
         | Some ("all", _) ->
             warn_payload loc txt "The alert name 'all' is reserved"
         | Some _ -> ()
         | None -> warn_payload loc txt "Invalid payload") in
  function
  | { attr_name = { txt = ("ocaml.warning" | "warning" as txt);_}; attr_loc;
      attr_payload } -> process attr_loc txt false attr_payload
  | { attr_name = { txt = ("ocaml.warnerror" | "warnerror" as txt);_};
      attr_loc; attr_payload } -> process attr_loc txt true attr_payload
  | { attr_name = { txt = ("ocaml.ppwarning" | "ppwarning");_}; attr_loc = _;
      attr_payload = PStr
        ({
           pstr_desc = Pstr_eval
             ({ pexp_desc = Pexp_constant (Pconst_string (s, _, _)) }, _);
           pstr_loc }::[])
      } when ppwarning ->
      Location.prerr_warning pstr_loc (Warnings.Preprocessor s)
  | { attr_name = { txt = ("ocaml.alert" | "alert" as txt);_}; attr_loc;
      attr_payload } -> process_alert attr_loc txt attr_payload
  | _ -> ()
let warning_scope ?ppwarning  attrs f =
  let prev = Warnings.backup () in
  try
    List.iter (warning_attribute ?ppwarning) (List.rev attrs);
    (let ret = f () in Warnings.restore prev; ret)
  with | exn -> (Warnings.restore prev; raise exn)
let warn_on_literal_pattern =
  List.exists
    (fun a ->
       match (a.attr_name).txt with
       | "ocaml.warn_on_literal_pattern" | "warn_on_literal_pattern" -> true
       | _ -> false)
let explicit_arity =
  List.exists
    (fun a ->
       match (a.attr_name).txt with
       | "ocaml.explicit_arity" | "explicit_arity" -> true
       | _ -> false)
let immediate =
  List.exists
    (fun a ->
       match (a.attr_name).txt with
       | "ocaml.immediate" | "immediate" -> true
       | _ -> false)
let immediate64 =
  List.exists
    (fun a ->
       match (a.attr_name).txt with
       | "ocaml.immediate64" | "immediate64" -> true
       | _ -> false)
let check l a = List.mem (a.attr_name).txt l
let has_unboxed attr = List.exists (check ["ocaml.unboxed"; "unboxed"]) attr
let has_boxed attr = List.exists (check ["ocaml.boxed"; "boxed"]) attr
File "lib/builtin_attributes.ml", line 24, characters 30-57:
24 |   | PStr[{pstr_desc=Pstr_eval({pexp_desc=Pexp_constant c},_)}] ->
                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
pexp_loc, pexp_loc_stack, pexp_attributes
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", line 24, characters 9-61:
24 |   | PStr[{pstr_desc=Pstr_eval({pexp_desc=Pexp_constant c},_)}] ->
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
pstr_loc
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", lines 35-36, characters 6-58:
35 | ......{pstr_desc=Pstr_extension
36 |            (({txt = ("ocaml.error"|"error"); loc}, p), _)}...
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
pstr_loc
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", line 47, characters 6-53:
47 |     | {pstr_desc=Pstr_extension (({txt; loc}, _), _)} ->
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
pstr_loc
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", line 39, characters 22-71:
39 |                      ({pexp_desc=Pexp_constant(Pconst_string(msg,_,_))}, _)}
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
pexp_loc, pexp_loc_stack, pexp_attributes
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", lines 38-39, characters 16-76:
38 | ................{pstr_desc=Pstr_eval
39 |                      ({pexp_desc=Pexp_constant(Pconst_string(msg,_,_))}, _)}
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
pstr_loc
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", line 60, characters 19-68:
60 |                   ({pexp_desc=Pexp_constant(Pconst_string(msg,_,_))}, _)}::
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
pexp_loc, pexp_loc_stack, pexp_attributes
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", lines 59-60, characters 13-73:
59 | .............{pstr_desc=Pstr_eval
60 |                   ({pexp_desc=Pexp_constant(Pconst_string(msg,_,_))}, _)}..
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
pstr_loc
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", line 75, characters 39-64:
75 |                  ({pexp_desc=Pexp_ident{txt=Longident.Lident id}},
                                            ^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
loc
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", line 75, characters 18-65:
75 |                  ({pexp_desc=Pexp_ident{txt=Longident.Lident id}},
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
pexp_loc, pexp_loc_stack, pexp_attributes
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", line 76, characters 27-75:
76 |                   [Nolabel,{pexp_desc=Pexp_constant (Pconst_string(s,_,_))}])
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
pexp_loc, pexp_loc_stack, pexp_attributes
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", lines 74-77, characters 12-13:
74 | ............{pexp_desc=Pexp_apply
75 |                  ({pexp_desc=Pexp_ident{txt=Longident.Lident id}},
76 |                   [Nolabel,{pexp_desc=Pexp_constant (Pconst_string(s,_,_))}])
77 |             }........
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
pexp_loc, pexp_loc_stack, pexp_attributes
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", lines 72-77, characters 6-17:
72 | ......{pstr_desc=
73 |          Pstr_eval
74 |            ({pexp_desc=Pexp_apply
75 |                  ({pexp_desc=Pexp_ident{txt=Longident.Lident id}},
76 |                   [Nolabel,{pexp_desc=Pexp_constant (Pconst_string(s,_,_))}])
77 |             },_)}....
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
pstr_loc
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", line 82, characters 33-58:
82 |            ({pexp_desc=Pexp_ident{txt=Longident.Lident id}},_)}] ->
                                      ^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
loc
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", line 82, characters 12-59:
82 |            ({pexp_desc=Pexp_ident{txt=Longident.Lident id}},_)}] ->
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
pexp_loc, pexp_loc_stack, pexp_attributes
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", lines 80-82, characters 6-63:
80 | ......{pstr_desc=
81 |          Pstr_eval
82 |            ({pexp_desc=Pexp_ident{txt=Longident.Lident id}},_)}....
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
pstr_loc
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", lines 131-132, characters 4-22:
131 | ....{attr_name =  {txt = "ocaml.deprecated_mutable"|"deprecated_mutable"; _};
132 |      attr_payload = p}........
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
attr_loc
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", line 152, characters 4-34:
152 |   | {psig_desc = Psig_attribute a} :: tl ->
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
psig_loc
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", line 160, characters 4-34:
160 |   | {pstr_desc = Pstr_attribute a} :: tl ->
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
pstr_loc
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", line 193, characters 16-63:
193 |                 {pexp_desc=Pexp_constant(Pconst_string(s,_,_))},
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
pexp_loc, pexp_loc_stack, pexp_attributes
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", lines 191-195, characters 11-12:
191 | ...........{pstr_desc=
192 |               Pstr_eval(
193 |                 {pexp_desc=Pexp_constant(Pconst_string(s,_,_))},
194 |                 _)
195 |            }....
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
pstr_loc
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/builtin_attributes.ml", line 222, characters 23-74:
222 |              Pstr_eval({pexp_desc=Pexp_constant (Pconst_string (s, _, _))},_);
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
pexp_loc, pexp_loc_stack, pexp_attributes
Either bind these labels explicitly or add '; _' to the pattern.
+ as --debug-prefix-map '/mnt/data1/nix/time/2024/08/12/ocaml_introspector/_build/default'='/workspace_root' -o 'lib/.Typing.objs/native/typing__Builtin_attributes.o' '/tmp/build_9dd4b3_dune/camlasme4f095.s'
Done: 74% (32/43, 11 left) (jobs: 3)                                    Output[20]:
[@@@ocaml.ppx.context
  {
    tool_name = "ppx_driver";
    include_dirs = [];
    load_path = [];
    open_modules = [];
    for_package = None;
    debug = false;
    use_threads = false;
    use_vmthreads = false;
    recursive_types = false;
    principal = false;
    transparent_modules = false;
    unboxed_types = false;
    unsafe_string = false;
    cookies = [("library-name", "Typing")]
  }]
module Uid =
  struct
    type t =
      | Compilation_unit of string 
      | Item of {
      comp_unit: string ;
      id: int } 
      | Internal 
      | Predef of string 
    include
      (Identifiable.Make)(struct
                            type nonrec t = t
                            let equal (x : t) y = x = y
                            let compare (x : t) y = compare x y
                            let hash (x : t) = Hashtbl.hash x
                            let print fmt =
                              function
                              | Internal ->
                                  Format.pp_print_string fmt "<internal>"
                              | Predef name ->
                                  Format.fprintf fmt "<predef:%s>" name
                              | Compilation_unit s ->
                                  Format.pp_print_string fmt s
                              | Item { comp_unit; id } ->
                                  Format.fprintf fmt "%s.%d" comp_unit id
                            let output oc t =
                              let fmt = Format.formatter_of_out_channel oc in
                              print fmt t
                          end)
    let id = ref (-1)
    let reinit () = id := (-1)
    let mk ~current_unit  =
      incr id; Item { comp_unit = current_unit; id = (!id) }
    let of_compilation_unit_id id =
      if not (Ident.persistent id)
      then
        Misc.fatal_errorf "Types.Uid.of_compilation_unit_id %S"
          (Ident.name id);
      Compilation_unit (Ident.name id)
    let of_predef_id id =
      if not (Ident.is_predef id)
      then Misc.fatal_errorf "Types.Uid.of_predef_id %S" (Ident.name id);
      Predef (Ident.name id)
    let internal_not_actually_unique = Internal
    let for_actual_declaration = function | Item _ -> true | _ -> false
  end
module Sig_component_kind =
  struct
    type t =
      | Value 
      | Type 
      | Module 
      | Module_type 
      | Extension_constructor 
      | Class 
      | Class_type 
    let to_string =
      function
      | Value -> "value"
      | Type -> "type"
      | Module -> "module"
      | Module_type -> "module type"
      | Extension_constructor -> "extension constructor"
      | Class -> "class"
      | Class_type -> "class type"
    let can_appear_in_types =
      function
      | Value | Extension_constructor -> false
      | Type | Module | Module_type | Class | Class_type -> true
  end
module Item =
  struct
    module T =
      struct
        type t = (string * Sig_component_kind.t)
        let compare = compare
        let make str ns = (str, ns)
        let value id = ((Ident.name id), Sig_component_kind.Value)
        let type_ id = ((Ident.name id), Sig_component_kind.Type)
        let module_ id = ((Ident.name id), Sig_component_kind.Module)
        let module_type id =
          ((Ident.name id), Sig_component_kind.Module_type)
        let extension_constructor id =
          ((Ident.name id), Sig_component_kind.Extension_constructor)
        let class_ id = ((Ident.name id), Sig_component_kind.Class)
        let class_type id = ((Ident.name id), Sig_component_kind.Class_type)
        let print fmt (name, ns) =
          Format.fprintf fmt "%S[%s]" name (Sig_component_kind.to_string ns)
      end
    include T
    module Map = (Map.Make)(T)
  end
type var = Ident.t
type t = {
  uid: Uid.t option ;
  desc: desc }
and desc =
  | Var of var 
  | Abs of var * t 
  | App of t * t 
  | Struct of t Item.Map.t 
  | Leaf 
  | Proj of t * Item.t 
  | Comp_unit of string 
let print fmt =
  let print_uid_opt =
    Format.pp_print_option (fun fmt -> Format.fprintf fmt "<%a>" Uid.print) in
  let rec aux fmt { uid; desc } =
    match desc with
    | Var id -> Format.fprintf fmt "%a%a" Ident.print id print_uid_opt uid
    | Abs (id, t) ->
        Format.fprintf fmt "Abs@[%a@,(@[%a,@ @[%a@]@])@]" print_uid_opt uid
          Ident.print id aux t
    | App (t1, t2) ->
        Format.fprintf fmt "@[%a(@,%a)%a@]" aux t1 aux t2 print_uid_opt uid
    | Leaf ->
        Format.fprintf fmt "<%a>" (Format.pp_print_option Uid.print) uid
    | Proj (t, item) ->
        (match uid with
         | None -> Format.fprintf fmt "@[%a@ .@ %a@]" aux t Item.print item
         | Some uid ->
             Format.fprintf fmt "@[(%a@ .@ %a)<%a>@]" aux t Item.print item
               Uid.print uid)
    | Comp_unit name -> Format.fprintf fmt "CU %s" name
    | Struct map ->
        let print_map fmt =
          Item.Map.iter
            (fun item ->
               fun t ->
                 Format.fprintf fmt "@[<hv 4>%a ->@ %a;@]@," Item.print item
                   aux t) in
        Format.fprintf fmt "{@[<v>%a@,%a@]}" print_uid_opt uid print_map map in
  Format.fprintf fmt "@[%a@]@;" aux
let fresh_var ?(name= "shape-var")  uid =
  let var = Ident.create_local name in
  (var, { uid = (Some uid); desc = (Var var) })
let for_unnamed_functor_param = Ident.create_local "()"
let var uid id = { uid = (Some uid); desc = (Var id) }
let abs ?uid  var body = { uid; desc = (Abs (var, body)) }
let str ?uid  map = { uid; desc = (Struct map) }
let leaf uid = { uid = (Some uid); desc = Leaf }
let proj ?uid  t item =
  match t.desc with
  | Leaf -> t
  | Struct map -> (try Item.Map.find item map with | Not_found -> t)
  | _ -> { uid; desc = (Proj (t, item)) }
let app ?uid  f ~arg  = { uid; desc = (App (f, arg)) }
let decompose_abs t =
  match t.desc with | Abs (x, t) -> Some (x, t) | _ -> None
module Make_reduce(Params:sig
                            type env
                            val fuel : int
                            val read_unit_shape :
                              unit_name:string -> t option
                            val find_shape : env -> Ident.t -> t
                          end) =
  struct
    type nf = {
      uid: Uid.t option ;
      desc: nf_desc }
    and nf_desc =
      | NVar of var 
      | NApp of nf * nf 
      | NAbs of local_env * var * t * delayed_nf 
      | NStruct of delayed_nf Item.Map.t 
      | NProj of nf * Item.t 
      | NLeaf 
      | NComp_unit of string 
      | NoFuelLeft of desc 
    and delayed_nf =
      | Thunk of local_env * t 
    and local_env = delayed_nf option Ident.Map.t
    let improve_uid uid (nf : nf) =
      match nf.uid with | Some _ -> nf | None -> { nf with uid }
    let in_memo_table memo_table memo_key f arg =
      match Hashtbl.find memo_table memo_key with
      | res -> res
      | exception Not_found ->
          let res = f arg in (Hashtbl.replace memo_table memo_key res; res)
    type env =
      {
      fuel: int ref ;
      global_env: Params.env ;
      local_env: local_env ;
      reduce_memo_table: ((local_env * t), nf) Hashtbl.t ;
      read_back_memo_table: (nf, t) Hashtbl.t }
    let bind env var shape =
      { env with local_env = (Ident.Map.add var shape env.local_env) }
    let rec reduce_ env t =
      let memo_key = ((env.local_env), t) in
      in_memo_table env.reduce_memo_table memo_key (reduce__ env) t
    and reduce__ ({ fuel; global_env; local_env;_} as env) (t : t) =
      let reduce env t = reduce_ env t in
      let delay_reduce env t = Thunk ((env.local_env), t) in
      let force (Thunk (local_env, t)) = reduce { env with local_env } t in
      let return desc = ({ uid = (t.uid); desc } : nf) in
      if (!fuel) < 0
      then return (NoFuelLeft (t.desc))
      else
        (match t.desc with
         | Comp_unit unit_name ->
             (match Params.read_unit_shape ~unit_name with
              | Some t -> reduce env t
              | None -> return (NComp_unit unit_name))
         | App (f, arg) ->
             let f = reduce env f in
             (match f.desc with
              | NAbs (clos_env, var, body, _body_nf) ->
                  let arg = delay_reduce env arg in
                  let env =
                    bind { env with local_env = clos_env } var (Some arg) in
                  (reduce env body) |> (improve_uid t.uid)
              | _ -> let arg = reduce env arg in return (NApp (f, arg)))
         | Proj (str, item) ->
             let str = reduce env str in
             let nored () = return (NProj (str, item)) in
             (match str.desc with
              | NStruct items ->
                  (match Item.Map.find item items with
                   | exception Not_found -> nored ()
                   | nf -> (force nf) |> (improve_uid t.uid))
              | _ -> nored ())
         | Abs (var, body) ->
             let body_nf = delay_reduce (bind env var None) body in
             return (NAbs (local_env, var, body, body_nf))
         | Var id ->
             (match Ident.Map.find id local_env with
              | None -> return (NVar id)
              | Some def -> force def
              | exception Not_found ->
                  (match Params.find_shape global_env id with
                   | exception Not_found -> return (NVar id)
                   | res when res = t -> return (NVar id)
                   | res -> (decr fuel; reduce env res)))
         | Leaf -> return NLeaf
         | Struct m ->
             let mnf = Item.Map.map (delay_reduce env) m in
             return (NStruct mnf))
    let rec read_back env (nf : nf) =
      (in_memo_table env.read_back_memo_table nf (read_back_ env) nf : 
      t)
    and read_back_ env (nf : nf) =
      ({ uid = (nf.uid); desc = (read_back_desc env nf.desc) } : t)
    and read_back_desc env desc =
      let read_back nf = read_back env nf in
      let read_back_force (Thunk (local_env, t)) =
        read_back (reduce_ { env with local_env } t) in
      match desc with
      | NVar v -> Var v
      | NApp (nft, nfu) -> App ((read_back nft), (read_back nfu))
      | NAbs (_env, x, _t, nf) -> Abs (x, (read_back_force nf))
      | NStruct nstr -> Struct (Item.Map.map read_back_force nstr)
      | NProj (nf, item) -> Proj ((read_back nf), item)
      | NLeaf -> Leaf
      | NComp_unit s -> Comp_unit s
      | NoFuelLeft t -> t
    let reduce global_env t =
      let fuel = ref Params.fuel in
      let reduce_memo_table = Hashtbl.create 42 in
      let read_back_memo_table = Hashtbl.create 42 in
      let local_env = Ident.Map.empty in
      let env =
        {
          fuel;
          global_env;
          reduce_memo_table;
          read_back_memo_table;
          local_env
        } in
      (reduce_ env t) |> (read_back env)
  end
module Local_reduce =
  (Make_reduce)(struct
                  type env = unit
                  let fuel = 10
                  let read_unit_shape ~unit_name:_  = None
                  let find_shape _env _id = raise Not_found
                end)
let local_reduce shape = Local_reduce.reduce () shape
let dummy_mod = { uid = None; desc = (Struct Item.Map.empty) }
let of_path ~find_shape  ~namespace  =
  let rec aux : Sig_component_kind.t -> Path.t -> t =
    fun ns ->
      function
      | Pident id -> find_shape ns id
      | Pdot (path, name) -> proj (aux Module path) (name, ns)
      | Papply (p1, p2) -> app (aux Module p1) ~arg:(aux Module p2) in
  aux namespace
let for_persistent_unit s =
  {
    uid = (Some (Uid.of_compilation_unit_id (Ident.create_persistent s)));
    desc = (Comp_unit s)
  }
let leaf_for_unpack = { uid = None; desc = Leaf }
let set_uid_if_none t uid =
  match t.uid with | None -> { t with uid = (Some uid) } | _ -> t
module Map =
  struct
    type shape = t
    type nonrec t = t Item.Map.t
    let empty = Item.Map.empty
    let add t item shape = Item.Map.add item shape t
    let add_value t id uid = Item.Map.add (Item.value id) (leaf uid) t
    let add_value_proj t id shape =
      let item = Item.value id in Item.Map.add item (proj shape item) t
    let add_type t id uid = Item.Map.add (Item.type_ id) (leaf uid) t
    let add_type_proj t id shape =
      let item = Item.type_ id in Item.Map.add item (proj shape item) t
    let add_module t id shape = Item.Map.add (Item.module_ id) shape t
    let add_module_proj t id shape =
      let item = Item.module_ id in Item.Map.add item (proj shape item) t
    let add_module_type t id uid =
      Item.Map.add (Item.module_type id) (leaf uid) t
    let add_module_type_proj t id shape =
      let item = Item.module_type id in Item.Map.add item (proj shape item) t
    let add_extcons t id uid =
      Item.Map.add (Item.extension_constructor id) (leaf uid) t
    let add_extcons_proj t id shape =
      let item = Item.extension_constructor id in
      Item.Map.add item (proj shape item) t
    let add_class t id uid = Item.Map.add (Item.class_ id) (leaf uid) t
    let add_class_proj t id shape =
      let item = Item.class_ id in Item.Map.add item (proj shape item) t
    let add_class_type t id uid =
      Item.Map.add (Item.class_type id) (leaf uid) t
    let add_class_type_proj t id shape =
      let item = Item.class_type id in Item.Map.add item (proj shape item) t
  end
+ as --debug-prefix-map '/mnt/data1/nix/time/2024/08/12/ocaml_introspector/_build/default'='/workspace_root' -o 'lib/.Typing.objs/native/typing__Shape.o' '/tmp/build_9dd4b3_dune/camlasm1df8fc.s'
Done: 74% (32/43, 11 left) (jobs: 3)                                    Output[22]:
[@@@ocaml.ppx.context
  {
    tool_name = "ppx_driver";
    include_dirs = [];
    load_path = [];
    open_modules = [];
    for_package = None;
    debug = false;
    use_threads = false;
    use_vmthreads = false;
    recursive_types = false;
    principal = false;
    transparent_modules = false;
    unboxed_types = false;
    unsafe_string = false;
    cookies = [("library-name", "Typing")]
  }]
open Asttypes
type transient_expr =
  {
  mutable desc: type_desc ;
  mutable level: int ;
  mutable scope: int ;
  id: int }
and type_expr = transient_expr
and type_desc =
  | Tvar of string option 
  | Tarrow of arg_label * type_expr * type_expr * commutable 
  | Ttuple of type_expr list 
  | Tconstr of Path.t * type_expr list * abbrev_memo ref 
  | Tobject of type_expr * (Path.t * type_expr list) option ref 
  | Tfield of string * field_kind * type_expr * type_expr 
  | Tnil 
  | Tlink of type_expr 
  | Tsubst of type_expr * type_expr option 
  | Tvariant of row_desc 
  | Tunivar of string option 
  | Tpoly of type_expr * type_expr list 
  | Tpackage of Path.t * (Longident.t * type_expr) list 
and row_desc =
  {
  row_fields: (label * row_field) list ;
  row_more: type_expr ;
  row_closed: bool ;
  row_fixed: fixed_explanation option ;
  row_name: (Path.t * type_expr list) option }
and fixed_explanation =
  | Univar of type_expr 
  | Fixed_private 
  | Reified of Path.t 
  | Rigid 
and row_field = [ `some ] row_field_gen
and _ row_field_gen =
  | RFpresent: type_expr option -> [> `some ] row_field_gen 
  | RFeither:
  {
  no_arg: bool ;
  arg_type: type_expr list ;
  matched: bool ;
  ext: [ `some  | `none ] row_field_gen ref } -> [> `some ] row_field_gen 
  | RFabsent: [> `some ] row_field_gen 
  | RFnone: [> `none ] row_field_gen 
and abbrev_memo =
  | Mnil 
  | Mcons of private_flag * Path.t * type_expr * type_expr * abbrev_memo 
  | Mlink of abbrev_memo ref 
and any = [ `some  | `none  | `var ]
and field_kind = [ `some  | `var ] field_kind_gen
and _ field_kind_gen =
  | FKvar: {
  mutable field_kind: any field_kind_gen } -> [> `var ] field_kind_gen 
  | FKprivate: [> `none ] field_kind_gen 
  | FKpublic: [> `some ] field_kind_gen 
  | FKabsent: [> `some ] field_kind_gen 
and commutable = [ `some  | `var ] commutable_gen
and _ commutable_gen =
  | Cok: [> `some ] commutable_gen 
  | Cunknown: [> `none ] commutable_gen 
  | Cvar: {
  mutable commu: any commutable_gen } -> [> `var ] commutable_gen 
module TransientTypeOps =
  struct
    type t = type_expr
    let compare t1 t2 = t1.id - t2.id
    let hash t = t.id
    let equal t1 t2 = t1 == t2
  end
module Uid = Shape.Uid
module MethSet = Misc.Stdlib.String.Set
module VarSet = Misc.Stdlib.String.Set
module Meths = Misc.Stdlib.String.Map
module Vars = Misc.Stdlib.String.Map
type value_description =
  {
  val_type: type_expr ;
  val_kind: value_kind ;
  val_loc: Location.t ;
  val_attributes: Parsetree.attributes ;
  val_uid: Uid.t }
and value_kind =
  | Val_reg 
  | Val_prim of Primitive.description 
  | Val_ivar of mutable_flag * string 
  | Val_self of class_signature * self_meths * Ident.t Vars.t * string 
  | Val_anc of class_signature * Ident.t Meths.t * string 
and self_meths =
  | Self_concrete of Ident.t Meths.t 
  | Self_virtual of Ident.t Meths.t ref 
and class_signature =
  {
  csig_self: type_expr ;
  mutable csig_self_row: type_expr ;
  mutable csig_vars: (mutable_flag * virtual_flag * type_expr) Vars.t ;
  mutable csig_meths: (method_privacy * virtual_flag * type_expr) Meths.t }
and method_privacy =
  | Mpublic 
  | Mprivate of field_kind 
module Variance =
  struct
    type t = int
    type f =
      | May_pos 
      | May_neg 
      | May_weak 
      | Inj 
      | Pos 
      | Neg 
      | Inv 
    let single =
      function
      | May_pos -> 1
      | May_neg -> 2
      | May_weak -> 4
      | Inj -> 8
      | Pos -> 16
      | Neg -> 32
      | Inv -> 64
    let union v1 v2 = v1 lor v2
    let inter v1 v2 = v1 land v2
    let subset v1 v2 = (v1 land v2) = v1
    let eq (v1 : t) v2 = v1 = v2
    let set x b v = if b then v lor (single x) else v land (lnot (single x))
    let mem x = subset (single x)
    let null = 0
    let unknown = 7
    let full = 127
    let covariant = ((single May_pos) lor (single Pos)) lor (single Inj)
    let swap f1 f2 v = let v' = set f1 (mem f2 v) v in set f2 (mem f1 v) v'
    let conjugate v = swap May_pos May_neg (swap Pos Neg v)
    let get_upper v = ((mem May_pos v), (mem May_neg v))
    let get_lower v = ((mem Pos v), (mem Neg v), (mem Inv v), (mem Inj v))
    let unknown_signature ~injective  ~arity  =
      let v = if injective then set Inj true unknown else unknown in
      Misc.replicate_list v arity
  end
module Separability =
  struct
    type t =
      | Ind 
      | Sep 
      | Deepsep 
    type signature = t list
    let eq (m1 : t) m2 = m1 = m2
    let rank = function | Ind -> 0 | Sep -> 1 | Deepsep -> 2
    let compare m1 m2 = compare (rank m1) (rank m2)
    let max m1 m2 = if (rank m1) >= (rank m2) then m1 else m2
    let print ppf =
      function
      | Ind -> Format.fprintf ppf "Ind"
      | Sep -> Format.fprintf ppf "Sep"
      | Deepsep -> Format.fprintf ppf "Deepsep"
    let print_signature ppf modes =
      let pp_sep ppf () = Format.fprintf ppf ",@," in
      Format.fprintf ppf "@[(%a)@]" (Format.pp_print_list ~pp_sep print)
        modes
    let default_signature ~arity  =
      let default_mode = if Config.flat_float_array then Deepsep else Ind in
      Misc.replicate_list default_mode arity
  end
type type_declaration =
  {
  type_params: type_expr list ;
  type_arity: int ;
  type_kind: type_decl_kind ;
  type_private: private_flag ;
  type_manifest: type_expr option ;
  type_variance: Variance.t list ;
  type_separability: Separability.t list ;
  type_is_newtype: bool ;
  type_expansion_scope: int ;
  type_loc: Location.t ;
  type_attributes: Parsetree.attributes ;
  type_immediate: Type_immediacy.t ;
  type_unboxed_default: bool ;
  type_uid: Uid.t }
and type_decl_kind = (label_declaration, constructor_declaration) type_kind
and ('lbl, 'cstr) type_kind =
  | Type_abstract 
  | Type_record of 'lbl list * record_representation 
  | Type_variant of 'cstr list * variant_representation 
  | Type_open 
and record_representation =
  | Record_regular 
  | Record_float 
  | Record_unboxed of bool 
  | Record_inlined of int 
  | Record_extension of Path.t 
and variant_representation =
  | Variant_regular 
  | Variant_unboxed 
and label_declaration =
  {
  ld_id: Ident.t ;
  ld_mutable: mutable_flag ;
  ld_type: type_expr ;
  ld_loc: Location.t ;
  ld_attributes: Parsetree.attributes ;
  ld_uid: Uid.t }
and constructor_declaration =
  {
  cd_id: Ident.t ;
  cd_args: constructor_arguments ;
  cd_res: type_expr option ;
  cd_loc: Location.t ;
  cd_attributes: Parsetree.attributes ;
  cd_uid: Uid.t }
and constructor_arguments =
  | Cstr_tuple of type_expr list 
  | Cstr_record of label_declaration list 
type extension_constructor =
  {
  ext_type_path: Path.t ;
  ext_type_params: type_expr list ;
  ext_args: constructor_arguments ;
  ext_ret_type: type_expr option ;
  ext_private: private_flag ;
  ext_loc: Location.t ;
  ext_attributes: Parsetree.attributes ;
  ext_uid: Uid.t }
and type_transparence =
  | Type_public 
  | Type_new 
  | Type_private 
type class_type =
  | Cty_constr of Path.t * type_expr list * class_type 
  | Cty_signature of class_signature 
  | Cty_arrow of arg_label * type_expr * class_type 
type class_declaration =
  {
  cty_params: type_expr list ;
  mutable cty_type: class_type ;
  cty_path: Path.t ;
  cty_new: type_expr option ;
  cty_variance: Variance.t list ;
  cty_loc: Location.t ;
  cty_attributes: Parsetree.attributes ;
  cty_uid: Uid.t }
type class_type_declaration =
  {
  clty_params: type_expr list ;
  clty_type: class_type ;
  clty_path: Path.t ;
  clty_variance: Variance.t list ;
  clty_loc: Location.t ;
  clty_attributes: Parsetree.attributes ;
  clty_uid: Uid.t }
type visibility =
  | Exported 
  | Hidden 
type module_type =
  | Mty_ident of Path.t 
  | Mty_signature of signature 
  | Mty_functor of functor_parameter * module_type 
  | Mty_alias of Path.t 
and functor_parameter =
  | Unit 
  | Named of Ident.t option * module_type 
and module_presence =
  | Mp_present 
  | Mp_absent 
and signature = signature_item list
and signature_item =
  | Sig_value of Ident.t * value_description * visibility 
  | Sig_type of Ident.t * type_declaration * rec_status * visibility 
  | Sig_typext of Ident.t * extension_constructor * ext_status * visibility 
  | Sig_module of Ident.t * module_presence * module_declaration * rec_status
  * visibility 
  | Sig_modtype of Ident.t * modtype_declaration * visibility 
  | Sig_class of Ident.t * class_declaration * rec_status * visibility 
  | Sig_class_type of Ident.t * class_type_declaration * rec_status *
  visibility 
and module_declaration =
  {
  md_type: module_type ;
  md_attributes: Parsetree.attributes ;
  md_loc: Location.t ;
  md_uid: Uid.t }
and modtype_declaration =
  {
  mtd_type: module_type option ;
  mtd_attributes: Parsetree.attributes ;
  mtd_loc: Location.t ;
  mtd_uid: Uid.t }
and rec_status =
  | Trec_not 
  | Trec_first 
  | Trec_next 
and ext_status =
  | Text_first 
  | Text_next 
  | Text_exception 
type constructor_description =
  {
  cstr_name: string ;
  cstr_res: type_expr ;
  cstr_existentials: type_expr list ;
  cstr_args: type_expr list ;
  cstr_arity: int ;
  cstr_tag: constructor_tag ;
  cstr_consts: int ;
  cstr_nonconsts: int ;
  cstr_generalized: bool ;
  cstr_private: private_flag ;
  cstr_loc: Location.t ;
  cstr_attributes: Parsetree.attributes ;
  cstr_inlined: type_declaration option ;
  cstr_uid: Uid.t }
and constructor_tag =
  | Cstr_constant of int 
  | Cstr_block of int 
  | Cstr_unboxed 
  | Cstr_extension of Path.t * bool 
let equal_tag t1 t2 =
  match (t1, t2) with
  | (Cstr_constant i1, Cstr_constant i2) -> i2 = i1
  | (Cstr_block i1, Cstr_block i2) -> i2 = i1
  | (Cstr_unboxed, Cstr_unboxed) -> true
  | (Cstr_extension (path1, b1), Cstr_extension (path2, b2)) ->
      (Path.same path1 path2) && (b1 = b2)
  | ((Cstr_constant _ | Cstr_block _ | Cstr_unboxed | Cstr_extension _), _)
      -> false
let may_equal_constr c1 c2 =
  (c1.cstr_arity = c2.cstr_arity) &&
    (match ((c1.cstr_tag), (c2.cstr_tag)) with
     | (Cstr_extension _, Cstr_extension _) -> true
     | (tag1, tag2) -> equal_tag tag1 tag2)
let item_visibility =
  function
  | Sig_value (_, _, vis) | Sig_type (_, _, _, vis) | Sig_typext
    (_, _, _, vis) | Sig_module (_, _, _, _, vis) | Sig_modtype (_, _, vis)
    | Sig_class (_, _, _, vis) | Sig_class_type (_, _, _, vis) -> vis
type label_description =
  {
  lbl_name: string ;
  lbl_res: type_expr ;
  lbl_arg: type_expr ;
  lbl_mut: mutable_flag ;
  lbl_pos: int ;
  lbl_all: label_description array ;
  lbl_repres: record_representation ;
  lbl_private: private_flag ;
  lbl_loc: Location.t ;
  lbl_attributes: Parsetree.attributes ;
  lbl_uid: Uid.t }
let rec bound_value_identifiers =
  function
  | [] -> []
  | (Sig_value (id, { val_kind = Val_reg }, _))::rem -> id ::
      (bound_value_identifiers rem)
  | (Sig_typext (id, _, _, _))::rem -> id :: (bound_value_identifiers rem)
  | (Sig_module (id, Mp_present, _, _, _))::rem -> id ::
      (bound_value_identifiers rem)
  | (Sig_class (id, _, _, _))::rem -> id :: (bound_value_identifiers rem)
  | _::rem -> bound_value_identifiers rem
let signature_item_id =
  function
  | Sig_value (id, _, _) | Sig_type (id, _, _, _) | Sig_typext (id, _, _, _)
    | Sig_module (id, _, _, _, _) | Sig_modtype (id, _, _) | Sig_class
    (id, _, _, _) | Sig_class_type (id, _, _, _) -> id
type change =
  | Ctype of type_expr * type_desc 
  | Ccompress of type_expr * type_desc * type_desc 
  | Clevel of type_expr * int 
  | Cscope of type_expr * int 
  | Cname of (Path.t * type_expr list) option ref * (Path.t * type_expr list)
  option 
  | Crow of [ `none  | `some ] row_field_gen ref 
  | Ckind of [ `var ] field_kind_gen 
  | Ccommu of [ `var ] commutable_gen 
  | Cuniv of type_expr option ref * type_expr option 
type changes =
  | Change of change * changes ref 
  | Unchanged 
  | Invalid 
let trail = Local_store.s_table ref Unchanged
let log_change ch =
  let r' = ref Unchanged in (!trail) := (Change (ch, r')); trail := r'
type field_kind_view =
  | Fprivate 
  | Fpublic 
  | Fabsent 
let rec field_kind_internal_repr : field_kind -> field_kind =
  function
  | FKvar { field_kind = (FKvar _ | FKpublic | FKabsent as fk) } ->
      field_kind_internal_repr fk
  | kind -> kind
let field_kind_repr fk =
  match field_kind_internal_repr fk with
  | FKvar _ -> Fprivate
  | FKpublic -> Fpublic
  | FKabsent -> Fabsent
let field_public = FKpublic
let field_absent = FKabsent
let field_private () = FKvar { field_kind = FKprivate }
let rec is_commu_ok : type a. a commutable_gen -> bool =
  function
  | Cvar { commu } -> is_commu_ok commu
  | Cunknown -> false
  | Cok -> true
let commu_ok = Cok
let commu_var () = Cvar { commu = Cunknown }
let rec repr_link (t : type_expr) d =
  (function
   | { desc = (Tlink t' as d') } -> repr_link t d' t'
   | { desc = (Tfield (_, k, _, t') as d') } when
       (field_kind_internal_repr k) = FKabsent -> repr_link t d' t'
   | t' -> (log_change (Ccompress (t, (t.desc), d)); t.desc <- d; t') : 
  type_expr -> type_expr)
let repr_link1 t =
  function
  | { desc = (Tlink t' as d') } -> repr_link t d' t'
  | { desc = (Tfield (_, k, _, t') as d') } when
      (field_kind_internal_repr k) = FKabsent -> repr_link t d' t'
  | t' -> t'
let repr t =
  match t.desc with
  | Tlink t' -> repr_link1 t t'
  | Tfield (_, k, _, t') when (field_kind_internal_repr k) = FKabsent ->
      repr_link1 t t'
  | _ -> t
let get_desc t = (repr t).desc
let get_level t = (repr t).level
let get_scope t = (repr t).scope
let get_id t = (repr t).id
module Transient_expr =
  struct
    let create desc ~level  ~scope  ~id  = { desc; level; scope; id }
    let set_desc ty d = ty.desc <- d
    let set_stub_desc ty d = assert (ty.desc = (Tvar None)); ty.desc <- d
    let set_level ty lv = ty.level <- lv
    let set_scope ty sc = ty.scope <- sc
    let coerce ty = ty
    let repr = repr
    let type_expr ty = ty
  end
let eq_type t1 t2 = (t1 == t2) || ((repr t1) == (repr t2))
let compare_type t1 t2 = compare (get_id t1) (get_id t2)
let create_row ~fields  ~more  ~closed  ~fixed  ~name  =
  {
    row_fields = fields;
    row_more = more;
    row_closed = closed;
    row_fixed = fixed;
    row_name = name
  }
let rec row_fields row =
  match get_desc row.row_more with
  | Tvariant row' -> row.row_fields @ (row_fields row')
  | _ -> row.row_fields
let rec row_repr_no_fields row =
  match get_desc row.row_more with
  | Tvariant row' -> row_repr_no_fields row'
  | _ -> row
let row_more row = (row_repr_no_fields row).row_more
let row_closed row = (row_repr_no_fields row).row_closed
let row_fixed row = (row_repr_no_fields row).row_fixed
let row_name row = (row_repr_no_fields row).row_name
let rec get_row_field tag row =
  let rec find =
    function
    | (tag', f)::fields -> if tag = tag' then f else find fields
    | [] ->
        (match get_desc row.row_more with
         | Tvariant row' -> get_row_field tag row'
         | _ -> RFabsent) in
  find row.row_fields
let set_row_name row row_name =
  let row_fields = row_fields row in
  let row = row_repr_no_fields row in { row with row_fields; row_name }
type row_desc_repr =
  | Row of
  {
  fields: (label * row_field) list ;
  more: type_expr ;
  closed: bool ;
  fixed: fixed_explanation option ;
  name: (Path.t * type_expr list) option } 
let row_repr row =
  let fields = row_fields row in
  let row = row_repr_no_fields row in
  Row
    {
      fields;
      more = (row.row_more);
      closed = (row.row_closed);
      fixed = (row.row_fixed);
      name = (row.row_name)
    }
type row_field_view =
  | Rpresent of type_expr option 
  | Reither of bool * type_expr list * bool 
  | Rabsent 
let rec row_field_repr_aux tl =
  (function
   | RFeither ({ ext = { contents = RFnone } } as r) ->
       RFeither { r with arg_type = (tl @ r.arg_type) }
   | RFeither
       { arg_type;
         ext = { contents = (RFeither _ | RFpresent _ | RFabsent as rf) } }
       -> row_field_repr_aux (tl @ arg_type) rf
   | RFpresent (Some _) when tl <> [] -> RFpresent (Some (List.hd tl))
   | RFpresent _ as rf -> rf
   | RFabsent -> RFabsent : row_field -> row_field)
let row_field_repr fi =
  match row_field_repr_aux [] fi with
  | RFeither { no_arg; arg_type; matched } ->
      Reither (no_arg, arg_type, matched)
  | RFpresent t -> Rpresent t
  | RFabsent -> Rabsent
let rec row_field_ext (fi : row_field) =
  match fi with
  | RFeither { ext = ({ contents = RFnone } as ext) } -> ext
  | RFeither
      { ext = { contents = (RFeither _ | RFpresent _ | RFabsent as rf) } } ->
      row_field_ext rf
  | _ -> Misc.fatal_error "Types.row_field_ext "
let rf_present oty = RFpresent oty
let rf_absent = RFabsent
let rf_either ?use_ext_of  ~no_arg  arg_type ~matched  =
  let ext =
    match use_ext_of with | Some rf -> row_field_ext rf | None -> ref RFnone in
  RFeither { no_arg; arg_type; matched; ext }
let rf_either_of =
  function
  | None ->
      RFeither
        { no_arg = true; arg_type = []; matched = false; ext = (ref RFnone) }
  | Some ty ->
      RFeither
        {
          no_arg = false;
          arg_type = [ty];
          matched = false;
          ext = (ref RFnone)
        }
let eq_row_field_ext rf1 rf2 = (row_field_ext rf1) == (row_field_ext rf2)
let changed_row_field_exts l f =
  let exts = List.map row_field_ext l in
  f (); List.exists (fun r -> (!r) <> RFnone) exts
let match_row_field ~present  ~absent  ~either  (f : row_field) =
  match f with
  | RFabsent -> absent ()
  | RFpresent t -> present t
  | RFeither { no_arg; arg_type; matched; ext } ->
      let e : row_field option =
        match !ext with
        | RFnone -> None
        | RFeither _ | RFpresent _ | RFabsent as e -> Some e in
      either no_arg arg_type matched e
let new_id = Local_store.s_ref (-1)
let create_expr = Transient_expr.create
let newty3 ~level  ~scope  desc =
  incr new_id; create_expr desc ~level ~scope ~id:(!new_id)
let newty2 ~level  desc = newty3 ~level ~scope:Ident.lowest_scope desc
let undo_change =
  function
  | Ctype (ty, desc) -> Transient_expr.set_desc ty desc
  | Ccompress (ty, desc, _) -> Transient_expr.set_desc ty desc
  | Clevel (ty, level) -> Transient_expr.set_level ty level
  | Cscope (ty, scope) -> Transient_expr.set_scope ty scope
  | Cname (r, v) -> r := v
  | Crow r -> r := RFnone
  | Ckind (FKvar r) -> r.field_kind <- FKprivate
  | Ccommu (Cvar r) -> r.commu <- Cunknown
  | Cuniv (r, v) -> r := v
type snapshot = (changes ref * int)
let last_snapshot = Local_store.s_ref 0
let log_type ty =
  if ty.id <= (!last_snapshot) then log_change (Ctype (ty, (ty.desc)))
let link_type ty ty' =
  let ty = repr ty in
  let ty' = repr ty' in
  if ty == ty'
  then ()
  else
    (log_type ty;
     (let desc = ty.desc in
      Transient_expr.set_desc ty (Tlink ty');
      (match (desc, (ty'.desc)) with
       | (Tvar name, Tvar name') ->
           (match (name, name') with
            | (Some _, None) ->
                (log_type ty'; Transient_expr.set_desc ty' (Tvar name))
            | (None, Some _) -> ()
            | (Some _, Some _) ->
                if ty.level < ty'.level
                then (log_type ty'; Transient_expr.set_desc ty' (Tvar name))
            | (None, None) -> ())
       | _ -> ())))
let set_type_desc ty td =
  let ty = repr ty in
  if td != ty.desc then (log_type ty; Transient_expr.set_desc ty td)
let set_level ty level =
  let ty = repr ty in
  if level <> ty.level
  then
    (if ty.id <= (!last_snapshot) then log_change (Clevel (ty, (ty.level)));
     Transient_expr.set_level ty level)
let set_scope ty scope =
  let ty = repr ty in
  if scope <> ty.scope
  then
    (if ty.id <= (!last_snapshot) then log_change (Cscope (ty, (ty.scope)));
     Transient_expr.set_scope ty scope)
let set_univar rty ty = log_change (Cuniv (rty, (!rty))); rty := (Some ty)
let set_name nm v = log_change (Cname (nm, (!nm))); nm := v
let rec link_row_field_ext ~inside:(inside : row_field)  (v : row_field) =
  match inside with
  | RFeither { ext = ({ contents = RFnone } as e) } ->
      let RFeither _ | RFpresent _ | RFabsent as v = v in
      (log_change (Crow e); e := v)
  | RFeither
      { ext = { contents = (RFeither _ | RFpresent _ | RFabsent as rf) } } ->
      link_row_field_ext ~inside:rf v
  | _ -> invalid_arg "Types.link_row_field_ext"
let rec link_kind ~inside:(inside : field_kind)  (k : field_kind) =
  match inside with
  | FKvar ({ field_kind = FKprivate } as rk) as inside ->
      let FKvar _ | FKpublic | FKabsent as k = field_kind_internal_repr k in
      if k != inside then (log_change (Ckind inside); rk.field_kind <- k)
  | FKvar { field_kind = (FKvar _ | FKpublic | FKabsent as inside) } ->
      link_kind ~inside k
  | _ -> invalid_arg "Types.link_kind"
let rec commu_repr : commutable -> commutable =
  function
  | Cvar { commu = (Cvar _ | Cok as commu) } -> commu_repr commu
  | c -> c
let rec link_commu ~inside:(inside : commutable)  (c : commutable) =
  match inside with
  | Cvar ({ commu = Cunknown } as rc) as inside ->
      let Cvar _ | Cok as c = commu_repr c in
      if c != inside then (log_change (Ccommu inside); rc.commu <- c)
  | Cvar { commu = (Cvar _ | Cok as inside) } -> link_commu ~inside c
  | _ -> invalid_arg "Types.link_commu"
let set_commu_ok c = link_commu ~inside:c Cok
let snapshot () =
  let old = !last_snapshot in last_snapshot := (!new_id); ((!trail), old)
let rec rev_log accu =
  function
  | Unchanged -> accu
  | Invalid -> assert false
  | Change (ch, next) ->
      let d = !next in (next := Invalid; rev_log (ch :: accu) d)
let backtrack ~cleanup_abbrev  (changes, old) =
  match !changes with
  | Unchanged -> last_snapshot := old
  | Invalid -> failwith "Types.backtrack"
  | Change _ as change ->
      (cleanup_abbrev ();
       (let backlog = rev_log [] change in
        List.iter undo_change backlog;
        changes := Unchanged;
        last_snapshot := old;
        trail := changes))
let undo_first_change_after (changes, _) =
  match !changes with | Change (ch, _) -> undo_change ch | _ -> ()
let rec rev_compress_log log r =
  match !r with
  | Unchanged | Invalid -> log
  | Change (Ccompress _, next) -> rev_compress_log (r :: log) next
  | Change (_, next) -> rev_compress_log log next
let undo_compress (changes, _old) =
  match !changes with
  | Unchanged | Invalid -> ()
  | Change _ ->
      let log = rev_compress_log [] changes in
      List.iter
        (fun r ->
           match !r with
           | Change (Ccompress (ty, desc, d), next) when ty.desc == d ->
               (Transient_expr.set_desc ty desc; r := (!next))
           | _ -> ()) log
File "lib/types.ml", line 432, characters 18-38:
432 |   | Sig_value(id, {val_kind = Val_reg}, _) :: rem ->
                        ^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
val_type, val_loc, val_attributes, val_uid
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/types.ml", line 512, characters 3-26:
512 |    {desc = Tlink t' as d'} ->
         ^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
level, scope, id
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/types.ml", line 514, characters 3-38:
514 |  | {desc = Tfield (_, k, _, t') as d'}
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
level, scope, id
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/types.ml", line 523, characters 3-26:
523 |    {desc = Tlink t' as d'} ->
         ^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
level, scope, id
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/types.ml", line 525, characters 3-38:
525 |  | {desc = Tfield (_, k, _, t') as d'}
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
level, scope, id
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/types.ml", line 627, characters 14-41:
627 |   | RFeither ({ext = {contents = RFnone}} as r) ->
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
no_arg, arg_type, matched
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/types.ml", lines 629-630, characters 13-75:
629 | .............{arg_type;
630 |               ext = {contents = RFeither _ | RFpresent _ | RFabsent as rf}}...
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
no_arg, matched
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/types.ml", line 639, characters 13-40:
639 |   | RFeither {no_arg; arg_type; matched} -> Reither (no_arg, arg_type, matched)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
ext
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/types.ml", line 645, characters 13-47:
645 |   | RFeither {ext = {contents = RFnone} as ext} -> ext
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
no_arg, arg_type, matched
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/types.ml", line 646, characters 13-75:
646 |   | RFeither {ext = {contents = RFeither _ | RFpresent _ | RFabsent as rf}} ->
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
no_arg, arg_type, matched
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/types.ml", line 772, characters 13-45:
772 |   | RFeither {ext = {contents = RFnone} as e} ->
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
no_arg, arg_type, matched
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/types.ml", line 775, characters 13-75:
775 |   | RFeither {ext = {contents = RFeither _ | RFpresent _ | RFabsent as rf}} ->
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
no_arg, arg_type, matched
Either bind these labels explicitly or add '; _' to the pattern.
Done: 74% (32/43, 11 left) (jobs: 3)                                    Running[23]: (cd _build/default && /home/mdupont/.opam/4.14.0/bin/ocamlopt.opt -w @1..3@5..28@31..39@43@46..47@49..57@61..62@67@69-40 -strict-sequence -strict-formats -short-paths -keep-locs -warn-error -8-9-26-27-37-34-11-11-32-39 -annot -verbose -dsource -g -I lib/.Typing.objs/byte -I lib/.Typing.objs/native -I /home/mdupont/.opam/4.14.0/lib/ocaml-compiler-libs/common -I /home/mdupont/.opam/4.14.0/lib/ocaml-compiler-libs/shadow -I /home/mdupont/.opam/4.14.0/lib/ocaml/compiler-libs -I /home/mdupont/.opam/4.14.0/lib/ppx_derivers -I /home/mdupont/.opam/4.14.0/lib/ppxlib -I /home/mdupont/.opam/4.14.0/lib/ppxlib/ast -I /home/mdupont/.opam/4.14.0/lib/ppxlib/astlib -I /home/mdupont/.opam/4.14.0/lib/ppxlib/print_diff -I /home/mdupont/.opam/4.14.0/lib/ppxlib/stdppx -I /home/mdupont/.opam/4.14.0/lib/ppxlib/traverse_builtins -I /home/mdupont/.opam/4.14.0/lib/sexplib0 -I /home/mdupont/.opam/4.14.0/lib/stdlib-shims -intf-suffix .ml -no-alias-deps -opaque -open Typing -o lib/.Typing.objs/native/typing__Types.cmx -c -impl lib/types.pp.ml)
Done: 74% (32/43, 11 left) (jobs: 3)                                    Running[24]: (cd _build/default && /home/mdupont/.opam/4.14.0/bin/ocamlc.opt -w @1..3@5..28@31..39@43@46..47@49..57@61..62@67@69-40 -strict-sequence -strict-formats -short-paths -keep-locs -warn-error -8-9-26-27-37-34-11-11-32-39 -annot -verbose -dsource -g -bin-annot -I lib/.Typing.objs/byte -I /home/mdupont/.opam/4.14.0/lib/ocaml-compiler-libs/common -I /home/mdupont/.opam/4.14.0/lib/ocaml-compiler-libs/shadow -I /home/mdupont/.opam/4.14.0/lib/ocaml/compiler-libs -I /home/mdupont/.opam/4.14.0/lib/ppx_derivers -I /home/mdupont/.opam/4.14.0/lib/ppxlib -I /home/mdupont/.opam/4.14.0/lib/ppxlib/ast -I /home/mdupont/.opam/4.14.0/lib/ppxlib/astlib -I /home/mdupont/.opam/4.14.0/lib/ppxlib/print_diff -I /home/mdupont/.opam/4.14.0/lib/ppxlib/stdppx -I /home/mdupont/.opam/4.14.0/lib/ppxlib/traverse_builtins -I /home/mdupont/.opam/4.14.0/lib/sexplib0 -I /home/mdupont/.opam/4.14.0/lib/stdlib-shims -no-alias-deps -opaque -open Typing -o lib/.Typing.objs/byte/typing__Typedtree.cmo -c -impl lib/typedtree.pp.ml)
Done: 74% (32/43, 11 left) (jobs: 3)                                    Done: 86% (37/43, 6 left) (jobs: 2)                                   Output[24]:
[@@@ocaml.ppx.context
  {
    tool_name = "ppx_driver";
    include_dirs = [];
    load_path = [];
    open_modules = [];
    for_package = None;
    debug = false;
    use_threads = false;
    use_vmthreads = false;
    recursive_types = false;
    principal = false;
    transparent_modules = false;
    unboxed_types = false;
    unsafe_string = false;
    cookies = [("library-name", "Typing")]
  }]
open Asttypes
open Types
type partial =
  | Partial 
  | Total [@@deriving yojson]
type attribute = Parsetree.attribute[@@deriving yojson]
type attributes = attribute list[@@deriving yojson]
type value =
  | Value_pattern [@@deriving yojson]
type computation =
  | Computation_pattern [@@deriving yojson]
type _ pattern_category =
  | Value: value pattern_category 
  | Computation: computation pattern_category [@@deriving yojson]
type pattern = value general_pattern[@@deriving yojson]
and 'k general_pattern = 'k pattern_desc pattern_data[@@deriving yojson]
and 'a pattern_data =
  {
  pat_desc: 'a ;
  pat_loc: Location.t ;
  pat_extra: (pat_extra * Location.t * attribute list) list ;
  pat_type: type_expr ;
  pat_env: Env.t ;
  pat_attributes: attribute list }[@@deriving yojson]
and pat_extra =
  | Tpat_constraint of core_type 
  | Tpat_type of Path.t * Longident.t loc 
  | Tpat_open of Path.t * Longident.t loc * Env.t 
  | Tpat_unpack [@@deriving yojson]
and 'k pattern_desc =
  | Tpat_any: value pattern_desc 
  | Tpat_var: Ident.t * string loc -> value pattern_desc 
  | Tpat_alias: value general_pattern * Ident.t * string loc -> value
  pattern_desc 
  | Tpat_constant: constant -> value pattern_desc 
  | Tpat_tuple: value general_pattern list -> value pattern_desc 
  | Tpat_construct: Longident.t loc * constructor_description * value
  general_pattern list * (Ident.t loc list * core_type) option -> value
  pattern_desc 
  | Tpat_variant: label * value general_pattern option * row_desc ref ->
  value pattern_desc 
  | Tpat_record: (Longident.t loc * label_description * value
  general_pattern) list * closed_flag -> value pattern_desc 
  | Tpat_array: value general_pattern list -> value pattern_desc 
  | Tpat_lazy: value general_pattern -> value pattern_desc 
  | Tpat_value: tpat_value_argument -> computation pattern_desc 
  | Tpat_exception: value general_pattern -> computation pattern_desc 
  | Tpat_or: 'k general_pattern * 'k general_pattern * row_desc option -> 'k
  pattern_desc [@@deriving yojson]
and tpat_value_argument = value general_pattern[@@deriving yojson]
and expression =
  {
  exp_desc: expression_desc ;
  exp_loc: Location.t ;
  exp_extra: (exp_extra * Location.t * attribute list) list ;
  exp_type: type_expr ;
  exp_env: Env.t ;
  exp_attributes: attribute list }[@@deriving yojson]
and exp_extra =
  | Texp_constraint of core_type 
  | Texp_coerce of core_type option * core_type 
  | Texp_poly of core_type option 
  | Texp_newtype of string [@@deriving yojson]
and expression_desc =
  | Texp_ident of Path.t * Longident.t loc * Types.value_description 
  | Texp_constant of constant 
  | Texp_let of rec_flag * value_binding list * expression 
  | Texp_function of
  {
  arg_label: arg_label ;
  param: Ident.t ;
  cases: value case list ;
  partial: partial } 
  | Texp_apply of expression * (arg_label * expression option) list 
  | Texp_match of expression * computation case list * partial 
  | Texp_try of expression * value case list 
  | Texp_tuple of expression list 
  | Texp_construct of Longident.t loc * constructor_description * expression
  list 
  | Texp_variant of label * expression option 
  | Texp_record of
  {
  fields: (Types.label_description * record_label_definition) array ;
  representation: Types.record_representation ;
  extended_expression: expression option } 
  | Texp_field of expression * Longident.t loc * label_description 
  | Texp_setfield of expression * Longident.t loc * label_description *
  expression 
  | Texp_array of expression list 
  | Texp_ifthenelse of expression * expression * expression option 
  | Texp_sequence of expression * expression 
  | Texp_while of expression * expression 
  | Texp_for of Ident.t * Parsetree.pattern * expression * expression *
  direction_flag * expression 
  | Texp_send of expression * meth 
  | Texp_new of Path.t * Longident.t loc * Types.class_declaration 
  | Texp_instvar of Path.t * Path.t * string loc 
  | Texp_setinstvar of Path.t * Path.t * string loc * expression 
  | Texp_override of Path.t * (Ident.t * string loc * expression) list 
  | Texp_letmodule of Ident.t option * string option loc *
  Types.module_presence * module_expr * expression 
  | Texp_letexception of extension_constructor * expression 
  | Texp_assert of expression 
  | Texp_lazy of expression 
  | Texp_object of class_structure * string list 
  | Texp_pack of module_expr 
  | Texp_letop of
  {
  let_: binding_op ;
  ands: binding_op list ;
  param: Ident.t ;
  body: value case ;
  partial: partial } 
  | Texp_unreachable 
  | Texp_extension_constructor of Longident.t loc * Path.t 
  | Texp_open of open_declaration * expression [@@deriving yojson]
and meth =
  | Tmeth_name of string 
  | Tmeth_val of Ident.t 
  | Tmeth_ancestor of Ident.t * Path.t [@@deriving yojson]
and 'k case =
  {
  c_lhs: 'k general_pattern ;
  c_guard: expression option ;
  c_rhs: expression }[@@deriving yojson]
and record_label_definition =
  | Kept of Types.type_expr 
  | Overridden of Longident.t loc * expression [@@deriving yojson]
and binding_op =
  {
  bop_op_path: Path.t ;
  bop_op_name: string loc ;
  bop_op_val: Types.value_description ;
  bop_op_type: Types.type_expr ;
  bop_exp: expression ;
  bop_loc: Location.t }[@@deriving yojson]
and class_expr =
  {
  cl_desc: class_expr_desc ;
  cl_loc: Location.t ;
  cl_type: Types.class_type ;
  cl_env: Env.t ;
  cl_attributes: attribute list }[@@deriving yojson]
and class_expr_desc =
  | Tcl_ident of Path.t * Longident.t loc * core_type list 
  | Tcl_structure of class_structure 
  | Tcl_fun of arg_label * pattern * (Ident.t * expression) list * class_expr
  * partial 
  | Tcl_apply of class_expr * (arg_label * expression option) list 
  | Tcl_let of rec_flag * value_binding list * (Ident.t * expression) list *
  class_expr 
  | Tcl_constraint of class_expr * class_type option * string list * string
  list * MethSet.t 
  | Tcl_open of open_description * class_expr [@@deriving yojson]
and class_structure =
  {
  cstr_self: pattern ;
  cstr_fields: class_field list ;
  cstr_type: Types.class_signature ;
  cstr_meths: Ident.t Meths.t }[@@deriving yojson]
and class_field =
  {
  cf_desc: class_field_desc ;
  cf_loc: Location.t ;
  cf_attributes: attribute list }[@@deriving yojson]
and class_field_kind =
  | Tcfk_virtual of core_type 
  | Tcfk_concrete of override_flag * expression [@@deriving yojson]
and class_field_desc =
  | Tcf_inherit of override_flag * class_expr * string option * (string *
  Ident.t) list * (string * Ident.t) list 
  | Tcf_val of string loc * mutable_flag * Ident.t * class_field_kind * bool
  
  | Tcf_method of string loc * private_flag * class_field_kind 
  | Tcf_constraint of core_type * core_type 
  | Tcf_initializer of expression 
  | Tcf_attribute of attribute [@@deriving yojson]
and module_expr =
  {
  mod_desc: module_expr_desc ;
  mod_loc: Location.t ;
  mod_type: Types.module_type ;
  mod_env: Env.t ;
  mod_attributes: attribute list }[@@deriving yojson]
and module_type_constraint =
  | Tmodtype_implicit 
  | Tmodtype_explicit of module_type [@@deriving yojson]
and functor_parameter =
  | Unit 
  | Named of Ident.t option * string option loc * module_type [@@deriving
                                                                yojson]
and module_expr_desc =
  | Tmod_ident of Path.t * Longident.t loc 
  | Tmod_structure of structure 
  | Tmod_functor of functor_parameter * module_expr 
  | Tmod_apply of module_expr * module_expr * module_coercion 
  | Tmod_constraint of module_expr * Types.module_type *
  module_type_constraint * module_coercion 
  | Tmod_unpack of expression * Types.module_type [@@deriving yojson]
and structure =
  {
  str_items: structure_item list ;
  str_type: Types.signature ;
  str_final_env: Env.t }[@@deriving yojson]
and structure_item =
  {
  str_desc: structure_item_desc ;
  str_loc: Location.t ;
  str_env: Env.t }[@@deriving yojson]
and structure_item_desc =
  | Tstr_eval of expression * attributes 
  | Tstr_value of rec_flag * value_binding list 
  | Tstr_primitive of value_description 
  | Tstr_type of rec_flag * type_declaration list 
  | Tstr_typext of type_extension 
  | Tstr_exception of type_exception 
  | Tstr_module of module_binding 
  | Tstr_recmodule of module_binding list 
  | Tstr_modtype of module_type_declaration 
  | Tstr_open of open_declaration 
  | Tstr_class of (class_declaration * string list) list 
  | Tstr_class_type of (Ident.t * string loc * class_type_declaration) list 
  | Tstr_include of include_declaration 
  | Tstr_attribute of attribute [@@deriving yojson]
and module_binding =
  {
  mb_id: Ident.t option ;
  mb_name: string option loc ;
  mb_presence: module_presence ;
  mb_expr: module_expr ;
  mb_attributes: attribute list ;
  mb_loc: Location.t }[@@deriving yojson]
and value_binding =
  {
  vb_pat: pattern ;
  vb_expr: expression ;
  vb_attributes: attributes ;
  vb_loc: Location.t }[@@deriving yojson]
and module_coercion =
  | Tcoerce_none 
  | Tcoerce_structure of (int * module_coercion) list * (Ident.t * int *
  module_coercion) list 
  | Tcoerce_functor of module_coercion * module_coercion 
  | Tcoerce_primitive of primitive_coercion 
  | Tcoerce_alias of Env.t * Path.t * module_coercion [@@deriving yojson]
and module_type =
  {
  mty_desc: module_type_desc ;
  mty_type: Types.module_type ;
  mty_env: Env.t ;
  mty_loc: Location.t ;
  mty_attributes: attribute list }[@@deriving yojson]
and module_type_desc =
  | Tmty_ident of Path.t * Longident.t loc 
  | Tmty_signature of signature 
  | Tmty_functor of functor_parameter * module_type 
  | Tmty_with of module_type * (Path.t * Longident.t loc * with_constraint)
  list 
  | Tmty_typeof of module_expr 
  | Tmty_alias of Path.t * Longident.t loc [@@deriving yojson]
and primitive_coercion =
  {
  pc_desc: Primitive.description ;
  pc_type: type_expr ;
  pc_env: Env.t ;
  pc_loc: Location.t }[@@deriving yojson]
and signature =
  {
  sig_items: signature_item list ;
  sig_type: Types.signature ;
  sig_final_env: Env.t }[@@deriving yojson]
and signature_item =
  {
  sig_desc: signature_item_desc ;
  sig_env: Env.t ;
  sig_loc: Location.t }[@@deriving yojson]
and signature_item_desc =
  | Tsig_value of value_description 
  | Tsig_type of rec_flag * type_declaration list 
  | Tsig_typesubst of type_declaration list 
  | Tsig_typext of type_extension 
  | Tsig_exception of type_exception 
  | Tsig_module of module_declaration 
  | Tsig_modsubst of module_substitution 
  | Tsig_recmodule of module_declaration list 
  | Tsig_modtype of module_type_declaration 
  | Tsig_modtypesubst of module_type_declaration 
  | Tsig_open of open_description 
  | Tsig_include of include_description 
  | Tsig_class of class_description list 
  | Tsig_class_type of class_type_declaration list 
  | Tsig_attribute of attribute [@@deriving yojson]
and module_declaration =
  {
  md_id: Ident.t option ;
  md_name: string option loc ;
  md_presence: module_presence ;
  md_type: module_type ;
  md_attributes: attribute list ;
  md_loc: Location.t }[@@deriving yojson]
and module_substitution =
  {
  ms_id: Ident.t ;
  ms_name: string loc ;
  ms_manifest: Path.t ;
  ms_txt: Longident.t loc ;
  ms_attributes: attributes ;
  ms_loc: Location.t }[@@deriving yojson]
and module_type_declaration =
  {
  mtd_id: Ident.t ;
  mtd_name: string loc ;
  mtd_type: module_type option ;
  mtd_attributes: attribute list ;
  mtd_loc: Location.t }[@@deriving yojson]
and 'a open_infos =
  {
  open_expr: 'a ;
  open_bound_items: Types.signature ;
  open_override: override_flag ;
  open_env: Env.t ;
  open_loc: Location.t ;
  open_attributes: attribute list }[@@deriving yojson]
and open_description = (Path.t * Longident.t loc) open_infos[@@deriving
                                                              yojson]
and open_declaration = module_expr open_infos[@@deriving yojson]
and 'a include_infos =
  {
  incl_mod: 'a ;
  incl_type: Types.signature ;
  incl_loc: Location.t ;
  incl_attributes: attribute list }[@@deriving yojson]
and include_description = module_type include_infos[@@deriving yojson]
and include_declaration = module_expr include_infos[@@deriving yojson]
and with_constraint =
  | Twith_type of type_declaration 
  | Twith_module of Path.t * Longident.t loc 
  | Twith_modtype of module_type 
  | Twith_typesubst of type_declaration 
  | Twith_modsubst of Path.t * Longident.t loc 
  | Twith_modtypesubst of module_type [@@deriving yojson]
and core_type =
  {
  mutable ctyp_desc: core_type_desc ;
  mutable ctyp_type: type_expr ;
  ctyp_env: Env.t ;
  ctyp_loc: Location.t ;
  ctyp_attributes: attribute list }[@@deriving yojson]
and core_type_desc =
  | Ttyp_any 
  | Ttyp_var of string 
  | Ttyp_arrow of arg_label * core_type * core_type 
  | Ttyp_tuple of core_type list 
  | Ttyp_constr of Path.t * Longident.t loc * core_type list 
  | Ttyp_object of object_field list * closed_flag 
  | Ttyp_class of Path.t * Longident.t loc * core_type list 
  | Ttyp_alias of core_type * string 
  | Ttyp_variant of row_field list * closed_flag * label list option 
  | Ttyp_poly of string list * core_type 
  | Ttyp_package of package_type [@@deriving yojson]
and package_type =
  {
  pack_path: Path.t ;
  pack_fields: (Longident.t loc * core_type) list ;
  pack_type: Types.module_type ;
  pack_txt: Longident.t loc }[@@deriving yojson]
and row_field =
  {
  rf_desc: row_field_desc ;
  rf_loc: Location.t ;
  rf_attributes: attributes }[@@deriving yojson]
and row_field_desc =
  | Ttag of string loc * bool * core_type list 
  | Tinherit of core_type [@@deriving yojson]
and object_field =
  {
  of_desc: object_field_desc ;
  of_loc: Location.t ;
  of_attributes: attributes }[@@deriving yojson]
and object_field_desc =
  | OTtag of string loc * core_type 
  | OTinherit of core_type [@@deriving yojson]
and value_description =
  {
  val_id: Ident.t ;
  val_name: string loc ;
  val_desc: core_type ;
  val_val: Types.value_description ;
  val_prim: string list ;
  val_loc: Location.t ;
  val_attributes: attribute list }[@@deriving yojson]
and type_declaration =
  {
  typ_id: Ident.t ;
  typ_name: string loc ;
  typ_params: (core_type * (variance * injectivity)) list ;
  typ_type: Types.type_declaration ;
  typ_cstrs: (core_type * core_type * Location.t) list ;
  typ_kind: type_kind ;
  typ_private: private_flag ;
  typ_manifest: core_type option ;
  typ_loc: Location.t ;
  typ_attributes: attribute list }[@@deriving yojson]
and type_kind =
  | Ttype_abstract 
  | Ttype_variant of constructor_declaration list 
  | Ttype_record of label_declaration list 
  | Ttype_open [@@deriving yojson]
and label_declaration =
  {
  ld_id: Ident.t ;
  ld_name: string loc ;
  ld_mutable: mutable_flag ;
  ld_type: core_type ;
  ld_loc: Location.t ;
  ld_attributes: attribute list }[@@deriving yojson]
and constructor_declaration =
  {
  cd_id: Ident.t ;
  cd_name: string loc ;
  cd_vars: string loc list ;
  cd_args: constructor_arguments ;
  cd_res: core_type option ;
  cd_loc: Location.t ;
  cd_attributes: attribute list }[@@deriving yojson]
and constructor_arguments =
  | Cstr_tuple of core_type list 
  | Cstr_record of label_declaration list [@@deriving yojson]
and type_extension =
  {
  tyext_path: Path.t ;
  tyext_txt: Longident.t loc ;
  tyext_params: (core_type * (variance * injectivity)) list ;
  tyext_constructors: extension_constructor list ;
  tyext_private: private_flag ;
  tyext_loc: Location.t ;
  tyext_attributes: attribute list }[@@deriving yojson]
and type_exception =
  {
  tyexn_constructor: extension_constructor ;
  tyexn_loc: Location.t ;
  tyexn_attributes: attribute list }[@@deriving yojson]
and extension_constructor =
  {
  ext_id: Ident.t ;
  ext_name: string loc ;
  ext_type: Types.extension_constructor ;
  ext_kind: extension_constructor_kind ;
  ext_loc: Location.t ;
  ext_attributes: attribute list }[@@deriving yojson]
and extension_constructor_kind =
  | Text_decl of string loc list * constructor_arguments * core_type option 
  | Text_rebind of Path.t * Longident.t loc [@@deriving yojson]
and class_type =
  {
  cltyp_desc: class_type_desc ;
  cltyp_type: Types.class_type ;
  cltyp_env: Env.t ;
  cltyp_loc: Location.t ;
  cltyp_attributes: attribute list }[@@deriving yojson]
and class_type_desc =
  | Tcty_constr of Path.t * Longident.t loc * core_type list 
  | Tcty_signature of class_signature 
  | Tcty_arrow of arg_label * core_type * class_type 
  | Tcty_open of open_description * class_type [@@deriving yojson]
and class_signature =
  {
  csig_self: core_type ;
  csig_fields: class_type_field list ;
  csig_type: Types.class_signature }[@@deriving yojson]
and class_type_field =
  {
  ctf_desc: class_type_field_desc ;
  ctf_loc: Location.t ;
  ctf_attributes: attribute list }[@@deriving yojson]
and class_type_field_desc =
  | Tctf_inherit of class_type 
  | Tctf_val of (string * mutable_flag * virtual_flag * core_type) 
  | Tctf_method of (string * private_flag * virtual_flag * core_type) 
  | Tctf_constraint of (core_type * core_type) 
  | Tctf_attribute of attribute [@@deriving yojson]
and class_declaration = class_expr class_infos[@@deriving yojson]
and class_description = class_type class_infos[@@deriving yojson]
and class_type_declaration = class_type class_infos[@@deriving yojson]
and 'a class_infos =
  {
  ci_virt: virtual_flag ;
  ci_params: (core_type * (variance * injectivity)) list ;
  ci_id_name: string loc ;
  ci_id_class: Ident.t ;
  ci_id_class_type: Ident.t ;
  ci_id_object: Ident.t ;
  ci_id_typehash: Ident.t ;
  ci_expr: 'a ;
  ci_decl: Types.class_declaration ;
  ci_type_decl: Types.class_type_declaration ;
  ci_loc: Location.t ;
  ci_attributes: attribute list }
type implementation =
  {
  structure: structure ;
  coercion: module_coercion ;
  signature: Types.signature ;
  shape: Shape.t }
let as_computation_pattern (p : pattern) =
  ({
     pat_desc = (Tpat_value p);
     pat_loc = (p.pat_loc);
     pat_extra = [];
     pat_type = (p.pat_type);
     pat_env = (p.pat_env);
     pat_attributes = []
   } : computation general_pattern)
let rec classify_pattern_desc : type k. k pattern_desc -> k pattern_category
  =
  function
  | Tpat_alias _ -> Value
  | Tpat_tuple _ -> Value
  | Tpat_construct _ -> Value
  | Tpat_variant _ -> Value
  | Tpat_record _ -> Value
  | Tpat_array _ -> Value
  | Tpat_lazy _ -> Value
  | Tpat_any -> Value
  | Tpat_var _ -> Value
  | Tpat_constant _ -> Value
  | Tpat_value _ -> Computation
  | Tpat_exception _ -> Computation
  | Tpat_or (p1, p2, _) ->
      (match ((classify_pattern p1), (classify_pattern p2)) with
       | (Value, Value) -> Value
       | (Computation, Computation) -> Computation)[@@deriving yojson]
and classify_pattern : type k. k general_pattern -> k pattern_category =
  fun pat -> classify_pattern_desc pat.pat_desc
type pattern_action = {
  f: 'k . 'k general_pattern -> unit }[@@deriving yojson]
let shallow_iter_pattern_desc : type k.
  pattern_action -> k pattern_desc -> unit =
  fun f ->
    function
    | Tpat_alias (p, _, _) -> f.f p
    | Tpat_tuple patl -> List.iter f.f patl
    | Tpat_construct (_, _, patl, _) -> List.iter f.f patl
    | Tpat_variant (_, pat, _) -> Option.iter f.f pat
    | Tpat_record (lbl_pat_list, _) ->
        List.iter (fun (_, _, pat) -> f.f pat) lbl_pat_list
    | Tpat_array patl -> List.iter f.f patl
    | Tpat_lazy p -> f.f p
    | Tpat_any | Tpat_var _ | Tpat_constant _ -> ()
    | Tpat_value p -> f.f p
    | Tpat_exception p -> f.f p
    | Tpat_or (p1, p2, _) -> (f.f p1; f.f p2)
type pattern_transformation =
  {
  f: 'k . 'k general_pattern -> 'k general_pattern }[@@deriving yojson]
let shallow_map_pattern_desc : type k.
  pattern_transformation -> k pattern_desc -> k pattern_desc =
  fun f ->
    fun d ->
      match d with
      | Tpat_alias (p1, id, s) -> Tpat_alias ((f.f p1), id, s)
      | Tpat_tuple pats -> Tpat_tuple (List.map f.f pats)
      | Tpat_record (lpats, closed) ->
          Tpat_record
            ((List.map (fun (lid, l, p) -> (lid, l, (f.f p))) lpats), closed)
      | Tpat_construct (lid, c, pats, ty) ->
          Tpat_construct (lid, c, (List.map f.f pats), ty)
      | Tpat_array pats -> Tpat_array (List.map f.f pats)
      | Tpat_lazy p1 -> Tpat_lazy (f.f p1)
      | Tpat_variant (x1, Some p1, x2) ->
          Tpat_variant (x1, (Some (f.f p1)), x2)
      | Tpat_var _ | Tpat_constant _ | Tpat_any | Tpat_variant (_, None, _)
          -> d
      | Tpat_value p -> Tpat_value (f.f p)
      | Tpat_exception p -> Tpat_exception (f.f p)
      | Tpat_or (p1, p2, path) -> Tpat_or ((f.f p1), (f.f p2), path)
let rec iter_general_pattern : type k.
  pattern_action -> k general_pattern -> unit =
  fun f ->
    fun p ->
      f.f p;
      shallow_iter_pattern_desc { f = (fun p -> iter_general_pattern f p) }
        p.pat_desc
let iter_pattern (f : pattern -> unit) =
  iter_general_pattern
    {
      f =
        (fun (type k) ->
           fun (p : k general_pattern) ->
             match classify_pattern p with | Value -> f p | Computation -> ())
    }
type pattern_predicate = {
  f: 'k . 'k general_pattern -> bool }[@@deriving yojson]
let exists_general_pattern (f : pattern_predicate) p =
  let exception Found  in
    match iter_general_pattern
            { f = (fun p -> if f.f p then raise Found else ()) } p
    with
    | exception Found -> true
    | () -> false
let exists_pattern (f : pattern -> bool) =
  exists_general_pattern
    {
      f =
        (fun (type k) ->
           fun (p : k general_pattern) ->
             match classify_pattern p with
             | Value -> f p
             | Computation -> false)
    }
let rec iter_bound_idents : type k. _ -> k general_pattern -> _ =
  fun f ->
    fun pat ->
      match pat.pat_desc with
      | Tpat_var (id, s) -> f (id, s, (pat.pat_type))
      | Tpat_alias (p, id, s) ->
          (iter_bound_idents f p; f (id, s, (pat.pat_type)))
      | Tpat_or (p1, _, _) -> iter_bound_idents f p1
      | d ->
          shallow_iter_pattern_desc { f = (fun p -> iter_bound_idents f p) }
            d
let rev_pat_bound_idents_full pat =
  let idents_full = ref [] in
  let add id_full = idents_full := (id_full :: (!idents_full)) in
  iter_bound_idents add pat; !idents_full
let rev_only_idents idents_full =
  List.rev_map (fun (id, _, _) -> id) idents_full
let pat_bound_idents_full pat = List.rev (rev_pat_bound_idents_full pat)
let pat_bound_idents pat = rev_only_idents (rev_pat_bound_idents_full pat)
let rev_let_bound_idents_full bindings =
  let idents_full = ref [] in
  let add id_full = idents_full := (id_full :: (!idents_full)) in
  List.iter (fun vb -> iter_bound_idents add vb.vb_pat) bindings;
  !idents_full
let let_bound_idents_full bindings =
  List.rev (rev_let_bound_idents_full bindings)
let let_bound_idents pat = rev_only_idents (rev_let_bound_idents_full pat)
let alpha_var env id = List.assoc id env
let rec alpha_pat : type k. _ -> k general_pattern -> k general_pattern =
  fun env ->
    fun p ->
      match p.pat_desc with
      | Tpat_var (id, s) ->
          {
            p with
            pat_desc =
              ((try Tpat_var ((alpha_var env id), s)
                with | Not_found -> Tpat_any))
          }
      | Tpat_alias (p1, id, s) ->
          let new_p = alpha_pat env p1 in
          (try
             { p with pat_desc = (Tpat_alias (new_p, (alpha_var env id), s))
             }
           with | Not_found -> new_p)
      | d ->
          let pat_desc =
            shallow_map_pattern_desc { f = (fun p -> alpha_pat env p) } d in
          { p with pat_desc }
let mkloc = Location.mkloc
let mknoloc = Location.mknoloc
let split_pattern pat =
  let combine_opts merge p1 p2 =
    match (p1, p2) with
    | (None, None) -> None
    | (Some p, None) | (None, Some p) -> Some p
    | (Some p1, Some p2) -> Some (merge p1 p2) in
  let into pat p1 p2 = { pat with pat_desc = (Tpat_or (p1, p2, None)) } in
  let rec split_pattern cpat =
    match cpat.pat_desc with
    | Tpat_value p -> ((Some p), None)
    | Tpat_exception p -> (None, (Some p))
    | Tpat_or (cp1, cp2, _) ->
        let (vals1, exns1) = split_pattern cp1 in
        let (vals2, exns2) = split_pattern cp2 in
        ((combine_opts (into cpat) vals1 vals2),
          (combine_opts (into cpat) exns1 exns2)) in
  split_pattern pat
Done: 86% (37/43, 6 left) (jobs: 2)                                   Running[25]: (cd _build/default && /home/mdupont/.opam/4.14.0/bin/ocamlopt.opt -w @1..3@5..28@31..39@43@46..47@49..57@61..62@67@69-40 -strict-sequence -strict-formats -short-paths -keep-locs -warn-error -8-9-26-27-37-34-11-11-32-39 -annot -verbose -dsource -g -I lib/.Typing.objs/byte -I lib/.Typing.objs/native -I /home/mdupont/.opam/4.14.0/lib/ocaml-compiler-libs/common -I /home/mdupont/.opam/4.14.0/lib/ocaml-compiler-libs/shadow -I /home/mdupont/.opam/4.14.0/lib/ocaml/compiler-libs -I /home/mdupont/.opam/4.14.0/lib/ppx_derivers -I /home/mdupont/.opam/4.14.0/lib/ppxlib -I /home/mdupont/.opam/4.14.0/lib/ppxlib/ast -I /home/mdupont/.opam/4.14.0/lib/ppxlib/astlib -I /home/mdupont/.opam/4.14.0/lib/ppxlib/print_diff -I /home/mdupont/.opam/4.14.0/lib/ppxlib/stdppx -I /home/mdupont/.opam/4.14.0/lib/ppxlib/traverse_builtins -I /home/mdupont/.opam/4.14.0/lib/sexplib0 -I /home/mdupont/.opam/4.14.0/lib/stdlib-shims -intf-suffix .ml -no-alias-deps -opaque -open Typing -o lib/.Typing.objs/native/typing__Typedtree.cmx -c -impl lib/typedtree.pp.ml)
Done: 86% (37/43, 6 left) (jobs: 2)                                   Running[26]: (cd _build/default && /home/mdupont/.opam/4.14.0/bin/ocamlc.opt -w @1..3@5..28@31..39@43@46..47@49..57@61..62@67@69-40 -strict-sequence -strict-formats -short-paths -keep-locs -warn-error -8-9-26-27-37-34-11-11-32-39 -annot -verbose -dsource -g -a -o lib/Typing.cma lib/.Typing.objs/byte/typing.cmo lib/.Typing.objs/byte/typing__Builtin_attributes.cmo lib/.Typing.objs/byte/typing__Shape.cmo lib/.Typing.objs/byte/typing__Type_immediacy.cmo lib/.Typing.objs/byte/typing__Types.cmo lib/.Typing.objs/byte/typing__Typedtree.cmo)
Done: 86% (37/43, 6 left) (jobs: 2)                                   Output[23]:
[@@@ocaml.ppx.context
  {
    tool_name = "ppx_driver";
    include_dirs = [];
    load_path = [];
    open_modules = [];
    for_package = None;
    debug = false;
    use_threads = false;
    use_vmthreads = false;
    recursive_types = false;
    principal = false;
    transparent_modules = false;
    unboxed_types = false;
    unsafe_string = false;
    cookies = [("library-name", "Typing")]
  }]
open Asttypes
type transient_expr =
  {
  mutable desc: type_desc ;
  mutable level: int ;
  mutable scope: int ;
  id: int }
and type_expr = transient_expr
and type_desc =
  | Tvar of string option 
  | Tarrow of arg_label * type_expr * type_expr * commutable 
  | Ttuple of type_expr list 
  | Tconstr of Path.t * type_expr list * abbrev_memo ref 
  | Tobject of type_expr * (Path.t * type_expr list) option ref 
  | Tfield of string * field_kind * type_expr * type_expr 
  | Tnil 
  | Tlink of type_expr 
  | Tsubst of type_expr * type_expr option 
  | Tvariant of row_desc 
  | Tunivar of string option 
  | Tpoly of type_expr * type_expr list 
  | Tpackage of Path.t * (Longident.t * type_expr) list 
and row_desc =
  {
  row_fields: (label * row_field) list ;
  row_more: type_expr ;
  row_closed: bool ;
  row_fixed: fixed_explanation option ;
  row_name: (Path.t * type_expr list) option }
and fixed_explanation =
  | Univar of type_expr 
  | Fixed_private 
  | Reified of Path.t 
  | Rigid 
and row_field = [ `some ] row_field_gen
and _ row_field_gen =
  | RFpresent: type_expr option -> [> `some ] row_field_gen 
  | RFeither:
  {
  no_arg: bool ;
  arg_type: type_expr list ;
  matched: bool ;
  ext: [ `some  | `none ] row_field_gen ref } -> [> `some ] row_field_gen 
  | RFabsent: [> `some ] row_field_gen 
  | RFnone: [> `none ] row_field_gen 
and abbrev_memo =
  | Mnil 
  | Mcons of private_flag * Path.t * type_expr * type_expr * abbrev_memo 
  | Mlink of abbrev_memo ref 
and any = [ `some  | `none  | `var ]
and field_kind = [ `some  | `var ] field_kind_gen
and _ field_kind_gen =
  | FKvar: {
  mutable field_kind: any field_kind_gen } -> [> `var ] field_kind_gen 
  | FKprivate: [> `none ] field_kind_gen 
  | FKpublic: [> `some ] field_kind_gen 
  | FKabsent: [> `some ] field_kind_gen 
and commutable = [ `some  | `var ] commutable_gen
and _ commutable_gen =
  | Cok: [> `some ] commutable_gen 
  | Cunknown: [> `none ] commutable_gen 
  | Cvar: {
  mutable commu: any commutable_gen } -> [> `var ] commutable_gen 
module TransientTypeOps =
  struct
    type t = type_expr
    let compare t1 t2 = t1.id - t2.id
    let hash t = t.id
    let equal t1 t2 = t1 == t2
  end
module Uid = Shape.Uid
module MethSet = Misc.Stdlib.String.Set
module VarSet = Misc.Stdlib.String.Set
module Meths = Misc.Stdlib.String.Map
module Vars = Misc.Stdlib.String.Map
type value_description =
  {
  val_type: type_expr ;
  val_kind: value_kind ;
  val_loc: Location.t ;
  val_attributes: Parsetree.attributes ;
  val_uid: Uid.t }
and value_kind =
  | Val_reg 
  | Val_prim of Primitive.description 
  | Val_ivar of mutable_flag * string 
  | Val_self of class_signature * self_meths * Ident.t Vars.t * string 
  | Val_anc of class_signature * Ident.t Meths.t * string 
and self_meths =
  | Self_concrete of Ident.t Meths.t 
  | Self_virtual of Ident.t Meths.t ref 
and class_signature =
  {
  csig_self: type_expr ;
  mutable csig_self_row: type_expr ;
  mutable csig_vars: (mutable_flag * virtual_flag * type_expr) Vars.t ;
  mutable csig_meths: (method_privacy * virtual_flag * type_expr) Meths.t }
and method_privacy =
  | Mpublic 
  | Mprivate of field_kind 
module Variance =
  struct
    type t = int
    type f =
      | May_pos 
      | May_neg 
      | May_weak 
      | Inj 
      | Pos 
      | Neg 
      | Inv 
    let single =
      function
      | May_pos -> 1
      | May_neg -> 2
      | May_weak -> 4
      | Inj -> 8
      | Pos -> 16
      | Neg -> 32
      | Inv -> 64
    let union v1 v2 = v1 lor v2
    let inter v1 v2 = v1 land v2
    let subset v1 v2 = (v1 land v2) = v1
    let eq (v1 : t) v2 = v1 = v2
    let set x b v = if b then v lor (single x) else v land (lnot (single x))
    let mem x = subset (single x)
    let null = 0
    let unknown = 7
    let full = 127
    let covariant = ((single May_pos) lor (single Pos)) lor (single Inj)
    let swap f1 f2 v = let v' = set f1 (mem f2 v) v in set f2 (mem f1 v) v'
    let conjugate v = swap May_pos May_neg (swap Pos Neg v)
    let get_upper v = ((mem May_pos v), (mem May_neg v))
    let get_lower v = ((mem Pos v), (mem Neg v), (mem Inv v), (mem Inj v))
    let unknown_signature ~injective  ~arity  =
      let v = if injective then set Inj true unknown else unknown in
      Misc.replicate_list v arity
  end
module Separability =
  struct
    type t =
      | Ind 
      | Sep 
      | Deepsep 
    type signature = t list
    let eq (m1 : t) m2 = m1 = m2
    let rank = function | Ind -> 0 | Sep -> 1 | Deepsep -> 2
    let compare m1 m2 = compare (rank m1) (rank m2)
    let max m1 m2 = if (rank m1) >= (rank m2) then m1 else m2
    let print ppf =
      function
      | Ind -> Format.fprintf ppf "Ind"
      | Sep -> Format.fprintf ppf "Sep"
      | Deepsep -> Format.fprintf ppf "Deepsep"
    let print_signature ppf modes =
      let pp_sep ppf () = Format.fprintf ppf ",@," in
      Format.fprintf ppf "@[(%a)@]" (Format.pp_print_list ~pp_sep print)
        modes
    let default_signature ~arity  =
      let default_mode = if Config.flat_float_array then Deepsep else Ind in
      Misc.replicate_list default_mode arity
  end
type type_declaration =
  {
  type_params: type_expr list ;
  type_arity: int ;
  type_kind: type_decl_kind ;
  type_private: private_flag ;
  type_manifest: type_expr option ;
  type_variance: Variance.t list ;
  type_separability: Separability.t list ;
  type_is_newtype: bool ;
  type_expansion_scope: int ;
  type_loc: Location.t ;
  type_attributes: Parsetree.attributes ;
  type_immediate: Type_immediacy.t ;
  type_unboxed_default: bool ;
  type_uid: Uid.t }
and type_decl_kind = (label_declaration, constructor_declaration) type_kind
and ('lbl, 'cstr) type_kind =
  | Type_abstract 
  | Type_record of 'lbl list * record_representation 
  | Type_variant of 'cstr list * variant_representation 
  | Type_open 
and record_representation =
  | Record_regular 
  | Record_float 
  | Record_unboxed of bool 
  | Record_inlined of int 
  | Record_extension of Path.t 
and variant_representation =
  | Variant_regular 
  | Variant_unboxed 
and label_declaration =
  {
  ld_id: Ident.t ;
  ld_mutable: mutable_flag ;
  ld_type: type_expr ;
  ld_loc: Location.t ;
  ld_attributes: Parsetree.attributes ;
  ld_uid: Uid.t }
and constructor_declaration =
  {
  cd_id: Ident.t ;
  cd_args: constructor_arguments ;
  cd_res: type_expr option ;
  cd_loc: Location.t ;
  cd_attributes: Parsetree.attributes ;
  cd_uid: Uid.t }
and constructor_arguments =
  | Cstr_tuple of type_expr list 
  | Cstr_record of label_declaration list 
type extension_constructor =
  {
  ext_type_path: Path.t ;
  ext_type_params: type_expr list ;
  ext_args: constructor_arguments ;
  ext_ret_type: type_expr option ;
  ext_private: private_flag ;
  ext_loc: Location.t ;
  ext_attributes: Parsetree.attributes ;
  ext_uid: Uid.t }
and type_transparence =
  | Type_public 
  | Type_new 
  | Type_private 
type class_type =
  | Cty_constr of Path.t * type_expr list * class_type 
  | Cty_signature of class_signature 
  | Cty_arrow of arg_label * type_expr * class_type 
type class_declaration =
  {
  cty_params: type_expr list ;
  mutable cty_type: class_type ;
  cty_path: Path.t ;
  cty_new: type_expr option ;
  cty_variance: Variance.t list ;
  cty_loc: Location.t ;
  cty_attributes: Parsetree.attributes ;
  cty_uid: Uid.t }
type class_type_declaration =
  {
  clty_params: type_expr list ;
  clty_type: class_type ;
  clty_path: Path.t ;
  clty_variance: Variance.t list ;
  clty_loc: Location.t ;
  clty_attributes: Parsetree.attributes ;
  clty_uid: Uid.t }
type visibility =
  | Exported 
  | Hidden 
type module_type =
  | Mty_ident of Path.t 
  | Mty_signature of signature 
  | Mty_functor of functor_parameter * module_type 
  | Mty_alias of Path.t 
and functor_parameter =
  | Unit 
  | Named of Ident.t option * module_type 
and module_presence =
  | Mp_present 
  | Mp_absent 
and signature = signature_item list
and signature_item =
  | Sig_value of Ident.t * value_description * visibility 
  | Sig_type of Ident.t * type_declaration * rec_status * visibility 
  | Sig_typext of Ident.t * extension_constructor * ext_status * visibility 
  | Sig_module of Ident.t * module_presence * module_declaration * rec_status
  * visibility 
  | Sig_modtype of Ident.t * modtype_declaration * visibility 
  | Sig_class of Ident.t * class_declaration * rec_status * visibility 
  | Sig_class_type of Ident.t * class_type_declaration * rec_status *
  visibility 
and module_declaration =
  {
  md_type: module_type ;
  md_attributes: Parsetree.attributes ;
  md_loc: Location.t ;
  md_uid: Uid.t }
and modtype_declaration =
  {
  mtd_type: module_type option ;
  mtd_attributes: Parsetree.attributes ;
  mtd_loc: Location.t ;
  mtd_uid: Uid.t }
and rec_status =
  | Trec_not 
  | Trec_first 
  | Trec_next 
and ext_status =
  | Text_first 
  | Text_next 
  | Text_exception 
type constructor_description =
  {
  cstr_name: string ;
  cstr_res: type_expr ;
  cstr_existentials: type_expr list ;
  cstr_args: type_expr list ;
  cstr_arity: int ;
  cstr_tag: constructor_tag ;
  cstr_consts: int ;
  cstr_nonconsts: int ;
  cstr_generalized: bool ;
  cstr_private: private_flag ;
  cstr_loc: Location.t ;
  cstr_attributes: Parsetree.attributes ;
  cstr_inlined: type_declaration option ;
  cstr_uid: Uid.t }
and constructor_tag =
  | Cstr_constant of int 
  | Cstr_block of int 
  | Cstr_unboxed 
  | Cstr_extension of Path.t * bool 
let equal_tag t1 t2 =
  match (t1, t2) with
  | (Cstr_constant i1, Cstr_constant i2) -> i2 = i1
  | (Cstr_block i1, Cstr_block i2) -> i2 = i1
  | (Cstr_unboxed, Cstr_unboxed) -> true
  | (Cstr_extension (path1, b1), Cstr_extension (path2, b2)) ->
      (Path.same path1 path2) && (b1 = b2)
  | ((Cstr_constant _ | Cstr_block _ | Cstr_unboxed | Cstr_extension _), _)
      -> false
let may_equal_constr c1 c2 =
  (c1.cstr_arity = c2.cstr_arity) &&
    (match ((c1.cstr_tag), (c2.cstr_tag)) with
     | (Cstr_extension _, Cstr_extension _) -> true
     | (tag1, tag2) -> equal_tag tag1 tag2)
let item_visibility =
  function
  | Sig_value (_, _, vis) | Sig_type (_, _, _, vis) | Sig_typext
    (_, _, _, vis) | Sig_module (_, _, _, _, vis) | Sig_modtype (_, _, vis)
    | Sig_class (_, _, _, vis) | Sig_class_type (_, _, _, vis) -> vis
type label_description =
  {
  lbl_name: string ;
  lbl_res: type_expr ;
  lbl_arg: type_expr ;
  lbl_mut: mutable_flag ;
  lbl_pos: int ;
  lbl_all: label_description array ;
  lbl_repres: record_representation ;
  lbl_private: private_flag ;
  lbl_loc: Location.t ;
  lbl_attributes: Parsetree.attributes ;
  lbl_uid: Uid.t }
let rec bound_value_identifiers =
  function
  | [] -> []
  | (Sig_value (id, { val_kind = Val_reg }, _))::rem -> id ::
      (bound_value_identifiers rem)
  | (Sig_typext (id, _, _, _))::rem -> id :: (bound_value_identifiers rem)
  | (Sig_module (id, Mp_present, _, _, _))::rem -> id ::
      (bound_value_identifiers rem)
  | (Sig_class (id, _, _, _))::rem -> id :: (bound_value_identifiers rem)
  | _::rem -> bound_value_identifiers rem
let signature_item_id =
  function
  | Sig_value (id, _, _) | Sig_type (id, _, _, _) | Sig_typext (id, _, _, _)
    | Sig_module (id, _, _, _, _) | Sig_modtype (id, _, _) | Sig_class
    (id, _, _, _) | Sig_class_type (id, _, _, _) -> id
type change =
  | Ctype of type_expr * type_desc 
  | Ccompress of type_expr * type_desc * type_desc 
  | Clevel of type_expr * int 
  | Cscope of type_expr * int 
  | Cname of (Path.t * type_expr list) option ref * (Path.t * type_expr list)
  option 
  | Crow of [ `none  | `some ] row_field_gen ref 
  | Ckind of [ `var ] field_kind_gen 
  | Ccommu of [ `var ] commutable_gen 
  | Cuniv of type_expr option ref * type_expr option 
type changes =
  | Change of change * changes ref 
  | Unchanged 
  | Invalid 
let trail = Local_store.s_table ref Unchanged
let log_change ch =
  let r' = ref Unchanged in (!trail) := (Change (ch, r')); trail := r'
type field_kind_view =
  | Fprivate 
  | Fpublic 
  | Fabsent 
let rec field_kind_internal_repr : field_kind -> field_kind =
  function
  | FKvar { field_kind = (FKvar _ | FKpublic | FKabsent as fk) } ->
      field_kind_internal_repr fk
  | kind -> kind
let field_kind_repr fk =
  match field_kind_internal_repr fk with
  | FKvar _ -> Fprivate
  | FKpublic -> Fpublic
  | FKabsent -> Fabsent
let field_public = FKpublic
let field_absent = FKabsent
let field_private () = FKvar { field_kind = FKprivate }
let rec is_commu_ok : type a. a commutable_gen -> bool =
  function
  | Cvar { commu } -> is_commu_ok commu
  | Cunknown -> false
  | Cok -> true
let commu_ok = Cok
let commu_var () = Cvar { commu = Cunknown }
let rec repr_link (t : type_expr) d =
  (function
   | { desc = (Tlink t' as d') } -> repr_link t d' t'
   | { desc = (Tfield (_, k, _, t') as d') } when
       (field_kind_internal_repr k) = FKabsent -> repr_link t d' t'
   | t' -> (log_change (Ccompress (t, (t.desc), d)); t.desc <- d; t') : 
  type_expr -> type_expr)
let repr_link1 t =
  function
  | { desc = (Tlink t' as d') } -> repr_link t d' t'
  | { desc = (Tfield (_, k, _, t') as d') } when
      (field_kind_internal_repr k) = FKabsent -> repr_link t d' t'
  | t' -> t'
let repr t =
  match t.desc with
  | Tlink t' -> repr_link1 t t'
  | Tfield (_, k, _, t') when (field_kind_internal_repr k) = FKabsent ->
      repr_link1 t t'
  | _ -> t
let get_desc t = (repr t).desc
let get_level t = (repr t).level
let get_scope t = (repr t).scope
let get_id t = (repr t).id
module Transient_expr =
  struct
    let create desc ~level  ~scope  ~id  = { desc; level; scope; id }
    let set_desc ty d = ty.desc <- d
    let set_stub_desc ty d = assert (ty.desc = (Tvar None)); ty.desc <- d
    let set_level ty lv = ty.level <- lv
    let set_scope ty sc = ty.scope <- sc
    let coerce ty = ty
    let repr = repr
    let type_expr ty = ty
  end
let eq_type t1 t2 = (t1 == t2) || ((repr t1) == (repr t2))
let compare_type t1 t2 = compare (get_id t1) (get_id t2)
let create_row ~fields  ~more  ~closed  ~fixed  ~name  =
  {
    row_fields = fields;
    row_more = more;
    row_closed = closed;
    row_fixed = fixed;
    row_name = name
  }
let rec row_fields row =
  match get_desc row.row_more with
  | Tvariant row' -> row.row_fields @ (row_fields row')
  | _ -> row.row_fields
let rec row_repr_no_fields row =
  match get_desc row.row_more with
  | Tvariant row' -> row_repr_no_fields row'
  | _ -> row
let row_more row = (row_repr_no_fields row).row_more
let row_closed row = (row_repr_no_fields row).row_closed
let row_fixed row = (row_repr_no_fields row).row_fixed
let row_name row = (row_repr_no_fields row).row_name
let rec get_row_field tag row =
  let rec find =
    function
    | (tag', f)::fields -> if tag = tag' then f else find fields
    | [] ->
        (match get_desc row.row_more with
         | Tvariant row' -> get_row_field tag row'
         | _ -> RFabsent) in
  find row.row_fields
let set_row_name row row_name =
  let row_fields = row_fields row in
  let row = row_repr_no_fields row in { row with row_fields; row_name }
type row_desc_repr =
  | Row of
  {
  fields: (label * row_field) list ;
  more: type_expr ;
  closed: bool ;
  fixed: fixed_explanation option ;
  name: (Path.t * type_expr list) option } 
let row_repr row =
  let fields = row_fields row in
  let row = row_repr_no_fields row in
  Row
    {
      fields;
      more = (row.row_more);
      closed = (row.row_closed);
      fixed = (row.row_fixed);
      name = (row.row_name)
    }
type row_field_view =
  | Rpresent of type_expr option 
  | Reither of bool * type_expr list * bool 
  | Rabsent 
let rec row_field_repr_aux tl =
  (function
   | RFeither ({ ext = { contents = RFnone } } as r) ->
       RFeither { r with arg_type = (tl @ r.arg_type) }
   | RFeither
       { arg_type;
         ext = { contents = (RFeither _ | RFpresent _ | RFabsent as rf) } }
       -> row_field_repr_aux (tl @ arg_type) rf
   | RFpresent (Some _) when tl <> [] -> RFpresent (Some (List.hd tl))
   | RFpresent _ as rf -> rf
   | RFabsent -> RFabsent : row_field -> row_field)
let row_field_repr fi =
  match row_field_repr_aux [] fi with
  | RFeither { no_arg; arg_type; matched } ->
      Reither (no_arg, arg_type, matched)
  | RFpresent t -> Rpresent t
  | RFabsent -> Rabsent
let rec row_field_ext (fi : row_field) =
  match fi with
  | RFeither { ext = ({ contents = RFnone } as ext) } -> ext
  | RFeither
      { ext = { contents = (RFeither _ | RFpresent _ | RFabsent as rf) } } ->
      row_field_ext rf
  | _ -> Misc.fatal_error "Types.row_field_ext "
let rf_present oty = RFpresent oty
let rf_absent = RFabsent
let rf_either ?use_ext_of  ~no_arg  arg_type ~matched  =
  let ext =
    match use_ext_of with | Some rf -> row_field_ext rf | None -> ref RFnone in
  RFeither { no_arg; arg_type; matched; ext }
let rf_either_of =
  function
  | None ->
      RFeither
        { no_arg = true; arg_type = []; matched = false; ext = (ref RFnone) }
  | Some ty ->
      RFeither
        {
          no_arg = false;
          arg_type = [ty];
          matched = false;
          ext = (ref RFnone)
        }
let eq_row_field_ext rf1 rf2 = (row_field_ext rf1) == (row_field_ext rf2)
let changed_row_field_exts l f =
  let exts = List.map row_field_ext l in
  f (); List.exists (fun r -> (!r) <> RFnone) exts
let match_row_field ~present  ~absent  ~either  (f : row_field) =
  match f with
  | RFabsent -> absent ()
  | RFpresent t -> present t
  | RFeither { no_arg; arg_type; matched; ext } ->
      let e : row_field option =
        match !ext with
        | RFnone -> None
        | RFeither _ | RFpresent _ | RFabsent as e -> Some e in
      either no_arg arg_type matched e
let new_id = Local_store.s_ref (-1)
let create_expr = Transient_expr.create
let newty3 ~level  ~scope  desc =
  incr new_id; create_expr desc ~level ~scope ~id:(!new_id)
let newty2 ~level  desc = newty3 ~level ~scope:Ident.lowest_scope desc
let undo_change =
  function
  | Ctype (ty, desc) -> Transient_expr.set_desc ty desc
  | Ccompress (ty, desc, _) -> Transient_expr.set_desc ty desc
  | Clevel (ty, level) -> Transient_expr.set_level ty level
  | Cscope (ty, scope) -> Transient_expr.set_scope ty scope
  | Cname (r, v) -> r := v
  | Crow r -> r := RFnone
  | Ckind (FKvar r) -> r.field_kind <- FKprivate
  | Ccommu (Cvar r) -> r.commu <- Cunknown
  | Cuniv (r, v) -> r := v
type snapshot = (changes ref * int)
let last_snapshot = Local_store.s_ref 0
let log_type ty =
  if ty.id <= (!last_snapshot) then log_change (Ctype (ty, (ty.desc)))
let link_type ty ty' =
  let ty = repr ty in
  let ty' = repr ty' in
  if ty == ty'
  then ()
  else
    (log_type ty;
     (let desc = ty.desc in
      Transient_expr.set_desc ty (Tlink ty');
      (match (desc, (ty'.desc)) with
       | (Tvar name, Tvar name') ->
           (match (name, name') with
            | (Some _, None) ->
                (log_type ty'; Transient_expr.set_desc ty' (Tvar name))
            | (None, Some _) -> ()
            | (Some _, Some _) ->
                if ty.level < ty'.level
                then (log_type ty'; Transient_expr.set_desc ty' (Tvar name))
            | (None, None) -> ())
       | _ -> ())))
let set_type_desc ty td =
  let ty = repr ty in
  if td != ty.desc then (log_type ty; Transient_expr.set_desc ty td)
let set_level ty level =
  let ty = repr ty in
  if level <> ty.level
  then
    (if ty.id <= (!last_snapshot) then log_change (Clevel (ty, (ty.level)));
     Transient_expr.set_level ty level)
let set_scope ty scope =
  let ty = repr ty in
  if scope <> ty.scope
  then
    (if ty.id <= (!last_snapshot) then log_change (Cscope (ty, (ty.scope)));
     Transient_expr.set_scope ty scope)
let set_univar rty ty = log_change (Cuniv (rty, (!rty))); rty := (Some ty)
let set_name nm v = log_change (Cname (nm, (!nm))); nm := v
let rec link_row_field_ext ~inside:(inside : row_field)  (v : row_field) =
  match inside with
  | RFeither { ext = ({ contents = RFnone } as e) } ->
      let RFeither _ | RFpresent _ | RFabsent as v = v in
      (log_change (Crow e); e := v)
  | RFeither
      { ext = { contents = (RFeither _ | RFpresent _ | RFabsent as rf) } } ->
      link_row_field_ext ~inside:rf v
  | _ -> invalid_arg "Types.link_row_field_ext"
let rec link_kind ~inside:(inside : field_kind)  (k : field_kind) =
  match inside with
  | FKvar ({ field_kind = FKprivate } as rk) as inside ->
      let FKvar _ | FKpublic | FKabsent as k = field_kind_internal_repr k in
      if k != inside then (log_change (Ckind inside); rk.field_kind <- k)
  | FKvar { field_kind = (FKvar _ | FKpublic | FKabsent as inside) } ->
      link_kind ~inside k
  | _ -> invalid_arg "Types.link_kind"
let rec commu_repr : commutable -> commutable =
  function
  | Cvar { commu = (Cvar _ | Cok as commu) } -> commu_repr commu
  | c -> c
let rec link_commu ~inside:(inside : commutable)  (c : commutable) =
  match inside with
  | Cvar ({ commu = Cunknown } as rc) as inside ->
      let Cvar _ | Cok as c = commu_repr c in
      if c != inside then (log_change (Ccommu inside); rc.commu <- c)
  | Cvar { commu = (Cvar _ | Cok as inside) } -> link_commu ~inside c
  | _ -> invalid_arg "Types.link_commu"
let set_commu_ok c = link_commu ~inside:c Cok
let snapshot () =
  let old = !last_snapshot in last_snapshot := (!new_id); ((!trail), old)
let rec rev_log accu =
  function
  | Unchanged -> accu
  | Invalid -> assert false
  | Change (ch, next) ->
      let d = !next in (next := Invalid; rev_log (ch :: accu) d)
let backtrack ~cleanup_abbrev  (changes, old) =
  match !changes with
  | Unchanged -> last_snapshot := old
  | Invalid -> failwith "Types.backtrack"
  | Change _ as change ->
      (cleanup_abbrev ();
       (let backlog = rev_log [] change in
        List.iter undo_change backlog;
        changes := Unchanged;
        last_snapshot := old;
        trail := changes))
let undo_first_change_after (changes, _) =
  match !changes with | Change (ch, _) -> undo_change ch | _ -> ()
let rec rev_compress_log log r =
  match !r with
  | Unchanged | Invalid -> log
  | Change (Ccompress _, next) -> rev_compress_log (r :: log) next
  | Change (_, next) -> rev_compress_log log next
let undo_compress (changes, _old) =
  match !changes with
  | Unchanged | Invalid -> ()
  | Change _ ->
      let log = rev_compress_log [] changes in
      List.iter
        (fun r ->
           match !r with
           | Change (Ccompress (ty, desc, d), next) when ty.desc == d ->
               (Transient_expr.set_desc ty desc; r := (!next))
           | _ -> ()) log
File "lib/types.ml", line 432, characters 18-38:
432 |   | Sig_value(id, {val_kind = Val_reg}, _) :: rem ->
                        ^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
val_type, val_loc, val_attributes, val_uid
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/types.ml", line 512, characters 3-26:
512 |    {desc = Tlink t' as d'} ->
         ^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
level, scope, id
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/types.ml", line 514, characters 3-38:
514 |  | {desc = Tfield (_, k, _, t') as d'}
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
level, scope, id
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/types.ml", line 523, characters 3-26:
523 |    {desc = Tlink t' as d'} ->
         ^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
level, scope, id
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/types.ml", line 525, characters 3-38:
525 |  | {desc = Tfield (_, k, _, t') as d'}
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
level, scope, id
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/types.ml", line 627, characters 14-41:
627 |   | RFeither ({ext = {contents = RFnone}} as r) ->
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
no_arg, arg_type, matched
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/types.ml", lines 629-630, characters 13-75:
629 | .............{arg_type;
630 |               ext = {contents = RFeither _ | RFpresent _ | RFabsent as rf}}...
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
no_arg, matched
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/types.ml", line 639, characters 13-40:
639 |   | RFeither {no_arg; arg_type; matched} -> Reither (no_arg, arg_type, matched)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
ext
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/types.ml", line 645, characters 13-47:
645 |   | RFeither {ext = {contents = RFnone} as ext} -> ext
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
no_arg, arg_type, matched
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/types.ml", line 646, characters 13-75:
646 |   | RFeither {ext = {contents = RFeither _ | RFpresent _ | RFabsent as rf}} ->
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
no_arg, arg_type, matched
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/types.ml", line 772, characters 13-45:
772 |   | RFeither {ext = {contents = RFnone} as e} ->
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
no_arg, arg_type, matched
Either bind these labels explicitly or add '; _' to the pattern.
File "lib/types.ml", line 775, characters 13-75:
775 |   | RFeither {ext = {contents = RFeither _ | RFpresent _ | RFabsent as rf}} ->
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 9 [missing-record-field-pattern]: the following labels are not bound in this record pattern:
no_arg, arg_type, matched
Either bind these labels explicitly or add '; _' to the pattern.
+ as --debug-prefix-map '/mnt/data1/nix/time/2024/08/12/ocaml_introspector/_build/default'='/workspace_root' -o 'lib/.Typing.objs/native/typing__Types.o' '/tmp/build_9dd4b3_dune/camlasm9d4676.s'
Done: 86% (37/43, 6 left) (jobs: 2)                                   Done: 93% (40/43, 3 left) (jobs: 1)                                   Output[25]:
[@@@ocaml.ppx.context
  {
    tool_name = "ppx_driver";
    include_dirs = [];
    load_path = [];
    open_modules = [];
    for_package = None;
    debug = false;
    use_threads = false;
    use_vmthreads = false;
    recursive_types = false;
    principal = false;
    transparent_modules = false;
    unboxed_types = false;
    unsafe_string = false;
    cookies = [("library-name", "Typing")]
  }]
open Asttypes
open Types
type partial =
  | Partial 
  | Total [@@deriving yojson]
type attribute = Parsetree.attribute[@@deriving yojson]
type attributes = attribute list[@@deriving yojson]
type value =
  | Value_pattern [@@deriving yojson]
type computation =
  | Computation_pattern [@@deriving yojson]
type _ pattern_category =
  | Value: value pattern_category 
  | Computation: computation pattern_category [@@deriving yojson]
type pattern = value general_pattern[@@deriving yojson]
and 'k general_pattern = 'k pattern_desc pattern_data[@@deriving yojson]
and 'a pattern_data =
  {
  pat_desc: 'a ;
  pat_loc: Location.t ;
  pat_extra: (pat_extra * Location.t * attribute list) list ;
  pat_type: type_expr ;
  pat_env: Env.t ;
  pat_attributes: attribute list }[@@deriving yojson]
and pat_extra =
  | Tpat_constraint of core_type 
  | Tpat_type of Path.t * Longident.t loc 
  | Tpat_open of Path.t * Longident.t loc * Env.t 
  | Tpat_unpack [@@deriving yojson]
and 'k pattern_desc =
  | Tpat_any: value pattern_desc 
  | Tpat_var: Ident.t * string loc -> value pattern_desc 
  | Tpat_alias: value general_pattern * Ident.t * string loc -> value
  pattern_desc 
  | Tpat_constant: constant -> value pattern_desc 
  | Tpat_tuple: value general_pattern list -> value pattern_desc 
  | Tpat_construct: Longident.t loc * constructor_description * value
  general_pattern list * (Ident.t loc list * core_type) option -> value
  pattern_desc 
  | Tpat_variant: label * value general_pattern option * row_desc ref ->
  value pattern_desc 
  | Tpat_record: (Longident.t loc * label_description * value
  general_pattern) list * closed_flag -> value pattern_desc 
  | Tpat_array: value general_pattern list -> value pattern_desc 
  | Tpat_lazy: value general_pattern -> value pattern_desc 
  | Tpat_value: tpat_value_argument -> computation pattern_desc 
  | Tpat_exception: value general_pattern -> computation pattern_desc 
  | Tpat_or: 'k general_pattern * 'k general_pattern * row_desc option -> 'k
  pattern_desc [@@deriving yojson]
and tpat_value_argument = value general_pattern[@@deriving yojson]
and expression =
  {
  exp_desc: expression_desc ;
  exp_loc: Location.t ;
  exp_extra: (exp_extra * Location.t * attribute list) list ;
  exp_type: type_expr ;
  exp_env: Env.t ;
  exp_attributes: attribute list }[@@deriving yojson]
and exp_extra =
  | Texp_constraint of core_type 
  | Texp_coerce of core_type option * core_type 
  | Texp_poly of core_type option 
  | Texp_newtype of string [@@deriving yojson]
and expression_desc =
  | Texp_ident of Path.t * Longident.t loc * Types.value_description 
  | Texp_constant of constant 
  | Texp_let of rec_flag * value_binding list * expression 
  | Texp_function of
  {
  arg_label: arg_label ;
  param: Ident.t ;
  cases: value case list ;
  partial: partial } 
  | Texp_apply of expression * (arg_label * expression option) list 
  | Texp_match of expression * computation case list * partial 
  | Texp_try of expression * value case list 
  | Texp_tuple of expression list 
  | Texp_construct of Longident.t loc * constructor_description * expression
  list 
  | Texp_variant of label * expression option 
  | Texp_record of
  {
  fields: (Types.label_description * record_label_definition) array ;
  representation: Types.record_representation ;
  extended_expression: expression option } 
  | Texp_field of expression * Longident.t loc * label_description 
  | Texp_setfield of expression * Longident.t loc * label_description *
  expression 
  | Texp_array of expression list 
  | Texp_ifthenelse of expression * expression * expression option 
  | Texp_sequence of expression * expression 
  | Texp_while of expression * expression 
  | Texp_for of Ident.t * Parsetree.pattern * expression * expression *
  direction_flag * expression 
  | Texp_send of expression * meth 
  | Texp_new of Path.t * Longident.t loc * Types.class_declaration 
  | Texp_instvar of Path.t * Path.t * string loc 
  | Texp_setinstvar of Path.t * Path.t * string loc * expression 
  | Texp_override of Path.t * (Ident.t * string loc * expression) list 
  | Texp_letmodule of Ident.t option * string option loc *
  Types.module_presence * module_expr * expression 
  | Texp_letexception of extension_constructor * expression 
  | Texp_assert of expression 
  | Texp_lazy of expression 
  | Texp_object of class_structure * string list 
  | Texp_pack of module_expr 
  | Texp_letop of
  {
  let_: binding_op ;
  ands: binding_op list ;
  param: Ident.t ;
  body: value case ;
  partial: partial } 
  | Texp_unreachable 
  | Texp_extension_constructor of Longident.t loc * Path.t 
  | Texp_open of open_declaration * expression [@@deriving yojson]
and meth =
  | Tmeth_name of string 
  | Tmeth_val of Ident.t 
  | Tmeth_ancestor of Ident.t * Path.t [@@deriving yojson]
and 'k case =
  {
  c_lhs: 'k general_pattern ;
  c_guard: expression option ;
  c_rhs: expression }[@@deriving yojson]
and record_label_definition =
  | Kept of Types.type_expr 
  | Overridden of Longident.t loc * expression [@@deriving yojson]
and binding_op =
  {
  bop_op_path: Path.t ;
  bop_op_name: string loc ;
  bop_op_val: Types.value_description ;
  bop_op_type: Types.type_expr ;
  bop_exp: expression ;
  bop_loc: Location.t }[@@deriving yojson]
and class_expr =
  {
  cl_desc: class_expr_desc ;
  cl_loc: Location.t ;
  cl_type: Types.class_type ;
  cl_env: Env.t ;
  cl_attributes: attribute list }[@@deriving yojson]
and class_expr_desc =
  | Tcl_ident of Path.t * Longident.t loc * core_type list 
  | Tcl_structure of class_structure 
  | Tcl_fun of arg_label * pattern * (Ident.t * expression) list * class_expr
  * partial 
  | Tcl_apply of class_expr * (arg_label * expression option) list 
  | Tcl_let of rec_flag * value_binding list * (Ident.t * expression) list *
  class_expr 
  | Tcl_constraint of class_expr * class_type option * string list * string
  list * MethSet.t 
  | Tcl_open of open_description * class_expr [@@deriving yojson]
and class_structure =
  {
  cstr_self: pattern ;
  cstr_fields: class_field list ;
  cstr_type: Types.class_signature ;
  cstr_meths: Ident.t Meths.t }[@@deriving yojson]
and class_field =
  {
  cf_desc: class_field_desc ;
  cf_loc: Location.t ;
  cf_attributes: attribute list }[@@deriving yojson]
and class_field_kind =
  | Tcfk_virtual of core_type 
  | Tcfk_concrete of override_flag * expression [@@deriving yojson]
and class_field_desc =
  | Tcf_inherit of override_flag * class_expr * string option * (string *
  Ident.t) list * (string * Ident.t) list 
  | Tcf_val of string loc * mutable_flag * Ident.t * class_field_kind * bool
  
  | Tcf_method of string loc * private_flag * class_field_kind 
  | Tcf_constraint of core_type * core_type 
  | Tcf_initializer of expression 
  | Tcf_attribute of attribute [@@deriving yojson]
and module_expr =
  {
  mod_desc: module_expr_desc ;
  mod_loc: Location.t ;
  mod_type: Types.module_type ;
  mod_env: Env.t ;
  mod_attributes: attribute list }[@@deriving yojson]
and module_type_constraint =
  | Tmodtype_implicit 
  | Tmodtype_explicit of module_type [@@deriving yojson]
and functor_parameter =
  | Unit 
  | Named of Ident.t option * string option loc * module_type [@@deriving
                                                                yojson]
and module_expr_desc =
  | Tmod_ident of Path.t * Longident.t loc 
  | Tmod_structure of structure 
  | Tmod_functor of functor_parameter * module_expr 
  | Tmod_apply of module_expr * module_expr * module_coercion 
  | Tmod_constraint of module_expr * Types.module_type *
  module_type_constraint * module_coercion 
  | Tmod_unpack of expression * Types.module_type [@@deriving yojson]
and structure =
  {
  str_items: structure_item list ;
  str_type: Types.signature ;
  str_final_env: Env.t }[@@deriving yojson]
and structure_item =
  {
  str_desc: structure_item_desc ;
  str_loc: Location.t ;
  str_env: Env.t }[@@deriving yojson]
and structure_item_desc =
  | Tstr_eval of expression * attributes 
  | Tstr_value of rec_flag * value_binding list 
  | Tstr_primitive of value_description 
  | Tstr_type of rec_flag * type_declaration list 
  | Tstr_typext of type_extension 
  | Tstr_exception of type_exception 
  | Tstr_module of module_binding 
  | Tstr_recmodule of module_binding list 
  | Tstr_modtype of module_type_declaration 
  | Tstr_open of open_declaration 
  | Tstr_class of (class_declaration * string list) list 
  | Tstr_class_type of (Ident.t * string loc * class_type_declaration) list 
  | Tstr_include of include_declaration 
  | Tstr_attribute of attribute [@@deriving yojson]
and module_binding =
  {
  mb_id: Ident.t option ;
  mb_name: string option loc ;
  mb_presence: module_presence ;
  mb_expr: module_expr ;
  mb_attributes: attribute list ;
  mb_loc: Location.t }[@@deriving yojson]
and value_binding =
  {
  vb_pat: pattern ;
  vb_expr: expression ;
  vb_attributes: attributes ;
  vb_loc: Location.t }[@@deriving yojson]
and module_coercion =
  | Tcoerce_none 
  | Tcoerce_structure of (int * module_coercion) list * (Ident.t * int *
  module_coercion) list 
  | Tcoerce_functor of module_coercion * module_coercion 
  | Tcoerce_primitive of primitive_coercion 
  | Tcoerce_alias of Env.t * Path.t * module_coercion [@@deriving yojson]
and module_type =
  {
  mty_desc: module_type_desc ;
  mty_type: Types.module_type ;
  mty_env: Env.t ;
  mty_loc: Location.t ;
  mty_attributes: attribute list }[@@deriving yojson]
and module_type_desc =
  | Tmty_ident of Path.t * Longident.t loc 
  | Tmty_signature of signature 
  | Tmty_functor of functor_parameter * module_type 
  | Tmty_with of module_type * (Path.t * Longident.t loc * with_constraint)
  list 
  | Tmty_typeof of module_expr 
  | Tmty_alias of Path.t * Longident.t loc [@@deriving yojson]
and primitive_coercion =
  {
  pc_desc: Primitive.description ;
  pc_type: type_expr ;
  pc_env: Env.t ;
  pc_loc: Location.t }[@@deriving yojson]
and signature =
  {
  sig_items: signature_item list ;
  sig_type: Types.signature ;
  sig_final_env: Env.t }[@@deriving yojson]
and signature_item =
  {
  sig_desc: signature_item_desc ;
  sig_env: Env.t ;
  sig_loc: Location.t }[@@deriving yojson]
and signature_item_desc =
  | Tsig_value of value_description 
  | Tsig_type of rec_flag * type_declaration list 
  | Tsig_typesubst of type_declaration list 
  | Tsig_typext of type_extension 
  | Tsig_exception of type_exception 
  | Tsig_module of module_declaration 
  | Tsig_modsubst of module_substitution 
  | Tsig_recmodule of module_declaration list 
  | Tsig_modtype of module_type_declaration 
  | Tsig_modtypesubst of module_type_declaration 
  | Tsig_open of open_description 
  | Tsig_include of include_description 
  | Tsig_class of class_description list 
  | Tsig_class_type of class_type_declaration list 
  | Tsig_attribute of attribute [@@deriving yojson]
and module_declaration =
  {
  md_id: Ident.t option ;
  md_name: string option loc ;
  md_presence: module_presence ;
  md_type: module_type ;
  md_attributes: attribute list ;
  md_loc: Location.t }[@@deriving yojson]
and module_substitution =
  {
  ms_id: Ident.t ;
  ms_name: string loc ;
  ms_manifest: Path.t ;
  ms_txt: Longident.t loc ;
  ms_attributes: attributes ;
  ms_loc: Location.t }[@@deriving yojson]
and module_type_declaration =
  {
  mtd_id: Ident.t ;
  mtd_name: string loc ;
  mtd_type: module_type option ;
  mtd_attributes: attribute list ;
  mtd_loc: Location.t }[@@deriving yojson]
and 'a open_infos =
  {
  open_expr: 'a ;
  open_bound_items: Types.signature ;
  open_override: override_flag ;
  open_env: Env.t ;
  open_loc: Location.t ;
  open_attributes: attribute list }[@@deriving yojson]
and open_description = (Path.t * Longident.t loc) open_infos[@@deriving
                                                              yojson]
and open_declaration = module_expr open_infos[@@deriving yojson]
and 'a include_infos =
  {
  incl_mod: 'a ;
  incl_type: Types.signature ;
  incl_loc: Location.t ;
  incl_attributes: attribute list }[@@deriving yojson]
and include_description = module_type include_infos[@@deriving yojson]
and include_declaration = module_expr include_infos[@@deriving yojson]
and with_constraint =
  | Twith_type of type_declaration 
  | Twith_module of Path.t * Longident.t loc 
  | Twith_modtype of module_type 
  | Twith_typesubst of type_declaration 
  | Twith_modsubst of Path.t * Longident.t loc 
  | Twith_modtypesubst of module_type [@@deriving yojson]
and core_type =
  {
  mutable ctyp_desc: core_type_desc ;
  mutable ctyp_type: type_expr ;
  ctyp_env: Env.t ;
  ctyp_loc: Location.t ;
  ctyp_attributes: attribute list }[@@deriving yojson]
and core_type_desc =
  | Ttyp_any 
  | Ttyp_var of string 
  | Ttyp_arrow of arg_label * core_type * core_type 
  | Ttyp_tuple of core_type list 
  | Ttyp_constr of Path.t * Longident.t loc * core_type list 
  | Ttyp_object of object_field list * closed_flag 
  | Ttyp_class of Path.t * Longident.t loc * core_type list 
  | Ttyp_alias of core_type * string 
  | Ttyp_variant of row_field list * closed_flag * label list option 
  | Ttyp_poly of string list * core_type 
  | Ttyp_package of package_type [@@deriving yojson]
and package_type =
  {
  pack_path: Path.t ;
  pack_fields: (Longident.t loc * core_type) list ;
  pack_type: Types.module_type ;
  pack_txt: Longident.t loc }[@@deriving yojson]
and row_field =
  {
  rf_desc: row_field_desc ;
  rf_loc: Location.t ;
  rf_attributes: attributes }[@@deriving yojson]
and row_field_desc =
  | Ttag of string loc * bool * core_type list 
  | Tinherit of core_type [@@deriving yojson]
and object_field =
  {
  of_desc: object_field_desc ;
  of_loc: Location.t ;
  of_attributes: attributes }[@@deriving yojson]
and object_field_desc =
  | OTtag of string loc * core_type 
  | OTinherit of core_type [@@deriving yojson]
and value_description =
  {
  val_id: Ident.t ;
  val_name: string loc ;
  val_desc: core_type ;
  val_val: Types.value_description ;
  val_prim: string list ;
  val_loc: Location.t ;
  val_attributes: attribute list }[@@deriving yojson]
and type_declaration =
  {
  typ_id: Ident.t ;
  typ_name: string loc ;
  typ_params: (core_type * (variance * injectivity)) list ;
  typ_type: Types.type_declaration ;
  typ_cstrs: (core_type * core_type * Location.t) list ;
  typ_kind: type_kind ;
  typ_private: private_flag ;
  typ_manifest: core_type option ;
  typ_loc: Location.t ;
  typ_attributes: attribute list }[@@deriving yojson]
and type_kind =
  | Ttype_abstract 
  | Ttype_variant of constructor_declaration list 
  | Ttype_record of label_declaration list 
  | Ttype_open [@@deriving yojson]
and label_declaration =
  {
  ld_id: Ident.t ;
  ld_name: string loc ;
  ld_mutable: mutable_flag ;
  ld_type: core_type ;
  ld_loc: Location.t ;
  ld_attributes: attribute list }[@@deriving yojson]
and constructor_declaration =
  {
  cd_id: Ident.t ;
  cd_name: string loc ;
  cd_vars: string loc list ;
  cd_args: constructor_arguments ;
  cd_res: core_type option ;
  cd_loc: Location.t ;
  cd_attributes: attribute list }[@@deriving yojson]
and constructor_arguments =
  | Cstr_tuple of core_type list 
  | Cstr_record of label_declaration list [@@deriving yojson]
and type_extension =
  {
  tyext_path: Path.t ;
  tyext_txt: Longident.t loc ;
  tyext_params: (core_type * (variance * injectivity)) list ;
  tyext_constructors: extension_constructor list ;
  tyext_private: private_flag ;
  tyext_loc: Location.t ;
  tyext_attributes: attribute list }[@@deriving yojson]
and type_exception =
  {
  tyexn_constructor: extension_constructor ;
  tyexn_loc: Location.t ;
  tyexn_attributes: attribute list }[@@deriving yojson]
and extension_constructor =
  {
  ext_id: Ident.t ;
  ext_name: string loc ;
  ext_type: Types.extension_constructor ;
  ext_kind: extension_constructor_kind ;
  ext_loc: Location.t ;
  ext_attributes: attribute list }[@@deriving yojson]
and extension_constructor_kind =
  | Text_decl of string loc list * constructor_arguments * core_type option 
  | Text_rebind of Path.t * Longident.t loc [@@deriving yojson]
and class_type =
  {
  cltyp_desc: class_type_desc ;
  cltyp_type: Types.class_type ;
  cltyp_env: Env.t ;
  cltyp_loc: Location.t ;
  cltyp_attributes: attribute list }[@@deriving yojson]
and class_type_desc =
  | Tcty_constr of Path.t * Longident.t loc * core_type list 
  | Tcty_signature of class_signature 
  | Tcty_arrow of arg_label * core_type * class_type 
  | Tcty_open of open_description * class_type [@@deriving yojson]
and class_signature =
  {
  csig_self: core_type ;
  csig_fields: class_type_field list ;
  csig_type: Types.class_signature }[@@deriving yojson]
and class_type_field =
  {
  ctf_desc: class_type_field_desc ;
  ctf_loc: Location.t ;
  ctf_attributes: attribute list }[@@deriving yojson]
and class_type_field_desc =
  | Tctf_inherit of class_type 
  | Tctf_val of (string * mutable_flag * virtual_flag * core_type) 
  | Tctf_method of (string * private_flag * virtual_flag * core_type) 
  | Tctf_constraint of (core_type * core_type) 
  | Tctf_attribute of attribute [@@deriving yojson]
and class_declaration = class_expr class_infos[@@deriving yojson]
and class_description = class_type class_infos[@@deriving yojson]
and class_type_declaration = class_type class_infos[@@deriving yojson]
and 'a class_infos =
  {
  ci_virt: virtual_flag ;
  ci_params: (core_type * (variance * injectivity)) list ;
  ci_id_name: string loc ;
  ci_id_class: Ident.t ;
  ci_id_class_type: Ident.t ;
  ci_id_object: Ident.t ;
  ci_id_typehash: Ident.t ;
  ci_expr: 'a ;
  ci_decl: Types.class_declaration ;
  ci_type_decl: Types.class_type_declaration ;
  ci_loc: Location.t ;
  ci_attributes: attribute list }
type implementation =
  {
  structure: structure ;
  coercion: module_coercion ;
  signature: Types.signature ;
  shape: Shape.t }
let as_computation_pattern (p : pattern) =
  ({
     pat_desc = (Tpat_value p);
     pat_loc = (p.pat_loc);
     pat_extra = [];
     pat_type = (p.pat_type);
     pat_env = (p.pat_env);
     pat_attributes = []
   } : computation general_pattern)
let rec classify_pattern_desc : type k. k pattern_desc -> k pattern_category
  =
  function
  | Tpat_alias _ -> Value
  | Tpat_tuple _ -> Value
  | Tpat_construct _ -> Value
  | Tpat_variant _ -> Value
  | Tpat_record _ -> Value
  | Tpat_array _ -> Value
  | Tpat_lazy _ -> Value
  | Tpat_any -> Value
  | Tpat_var _ -> Value
  | Tpat_constant _ -> Value
  | Tpat_value _ -> Computation
  | Tpat_exception _ -> Computation
  | Tpat_or (p1, p2, _) ->
      (match ((classify_pattern p1), (classify_pattern p2)) with
       | (Value, Value) -> Value
       | (Computation, Computation) -> Computation)[@@deriving yojson]
and classify_pattern : type k. k general_pattern -> k pattern_category =
  fun pat -> classify_pattern_desc pat.pat_desc
type pattern_action = {
  f: 'k . 'k general_pattern -> unit }[@@deriving yojson]
let shallow_iter_pattern_desc : type k.
  pattern_action -> k pattern_desc -> unit =
  fun f ->
    function
    | Tpat_alias (p, _, _) -> f.f p
    | Tpat_tuple patl -> List.iter f.f patl
    | Tpat_construct (_, _, patl, _) -> List.iter f.f patl
    | Tpat_variant (_, pat, _) -> Option.iter f.f pat
    | Tpat_record (lbl_pat_list, _) ->
        List.iter (fun (_, _, pat) -> f.f pat) lbl_pat_list
    | Tpat_array patl -> List.iter f.f patl
    | Tpat_lazy p -> f.f p
    | Tpat_any | Tpat_var _ | Tpat_constant _ -> ()
    | Tpat_value p -> f.f p
    | Tpat_exception p -> f.f p
    | Tpat_or (p1, p2, _) -> (f.f p1; f.f p2)
type pattern_transformation =
  {
  f: 'k . 'k general_pattern -> 'k general_pattern }[@@deriving yojson]
let shallow_map_pattern_desc : type k.
  pattern_transformation -> k pattern_desc -> k pattern_desc =
  fun f ->
    fun d ->
      match d with
      | Tpat_alias (p1, id, s) -> Tpat_alias ((f.f p1), id, s)
      | Tpat_tuple pats -> Tpat_tuple (List.map f.f pats)
      | Tpat_record (lpats, closed) ->
          Tpat_record
            ((List.map (fun (lid, l, p) -> (lid, l, (f.f p))) lpats), closed)
      | Tpat_construct (lid, c, pats, ty) ->
          Tpat_construct (lid, c, (List.map f.f pats), ty)
      | Tpat_array pats -> Tpat_array (List.map f.f pats)
      | Tpat_lazy p1 -> Tpat_lazy (f.f p1)
      | Tpat_variant (x1, Some p1, x2) ->
          Tpat_variant (x1, (Some (f.f p1)), x2)
      | Tpat_var _ | Tpat_constant _ | Tpat_any | Tpat_variant (_, None, _)
          -> d
      | Tpat_value p -> Tpat_value (f.f p)
      | Tpat_exception p -> Tpat_exception (f.f p)
      | Tpat_or (p1, p2, path) -> Tpat_or ((f.f p1), (f.f p2), path)
let rec iter_general_pattern : type k.
  pattern_action -> k general_pattern -> unit =
  fun f ->
    fun p ->
      f.f p;
      shallow_iter_pattern_desc { f = (fun p -> iter_general_pattern f p) }
        p.pat_desc
let iter_pattern (f : pattern -> unit) =
  iter_general_pattern
    {
      f =
        (fun (type k) ->
           fun (p : k general_pattern) ->
             match classify_pattern p with | Value -> f p | Computation -> ())
    }
type pattern_predicate = {
  f: 'k . 'k general_pattern -> bool }[@@deriving yojson]
let exists_general_pattern (f : pattern_predicate) p =
  let exception Found  in
    match iter_general_pattern
            { f = (fun p -> if f.f p then raise Found else ()) } p
    with
    | exception Found -> true
    | () -> false
let exists_pattern (f : pattern -> bool) =
  exists_general_pattern
    {
      f =
        (fun (type k) ->
           fun (p : k general_pattern) ->
             match classify_pattern p with
             | Value -> f p
             | Computation -> false)
    }
let rec iter_bound_idents : type k. _ -> k general_pattern -> _ =
  fun f ->
    fun pat ->
      match pat.pat_desc with
      | Tpat_var (id, s) -> f (id, s, (pat.pat_type))
      | Tpat_alias (p, id, s) ->
          (iter_bound_idents f p; f (id, s, (pat.pat_type)))
      | Tpat_or (p1, _, _) -> iter_bound_idents f p1
      | d ->
          shallow_iter_pattern_desc { f = (fun p -> iter_bound_idents f p) }
            d
let rev_pat_bound_idents_full pat =
  let idents_full = ref [] in
  let add id_full = idents_full := (id_full :: (!idents_full)) in
  iter_bound_idents add pat; !idents_full
let rev_only_idents idents_full =
  List.rev_map (fun (id, _, _) -> id) idents_full
let pat_bound_idents_full pat = List.rev (rev_pat_bound_idents_full pat)
let pat_bound_idents pat = rev_only_idents (rev_pat_bound_idents_full pat)
let rev_let_bound_idents_full bindings =
  let idents_full = ref [] in
  let add id_full = idents_full := (id_full :: (!idents_full)) in
  List.iter (fun vb -> iter_bound_idents add vb.vb_pat) bindings;
  !idents_full
let let_bound_idents_full bindings =
  List.rev (rev_let_bound_idents_full bindings)
let let_bound_idents pat = rev_only_idents (rev_let_bound_idents_full pat)
let alpha_var env id = List.assoc id env
let rec alpha_pat : type k. _ -> k general_pattern -> k general_pattern =
  fun env ->
    fun p ->
      match p.pat_desc with
      | Tpat_var (id, s) ->
          {
            p with
            pat_desc =
              ((try Tpat_var ((alpha_var env id), s)
                with | Not_found -> Tpat_any))
          }
      | Tpat_alias (p1, id, s) ->
          let new_p = alpha_pat env p1 in
          (try
             { p with pat_desc = (Tpat_alias (new_p, (alpha_var env id), s))
             }
           with | Not_found -> new_p)
      | d ->
          let pat_desc =
            shallow_map_pattern_desc { f = (fun p -> alpha_pat env p) } d in
          { p with pat_desc }
let mkloc = Location.mkloc
let mknoloc = Location.mknoloc
let split_pattern pat =
  let combine_opts merge p1 p2 =
    match (p1, p2) with
    | (None, None) -> None
    | (Some p, None) | (None, Some p) -> Some p
    | (Some p1, Some p2) -> Some (merge p1 p2) in
  let into pat p1 p2 = { pat with pat_desc = (Tpat_or (p1, p2, None)) } in
  let rec split_pattern cpat =
    match cpat.pat_desc with
    | Tpat_value p -> ((Some p), None)
    | Tpat_exception p -> (None, (Some p))
    | Tpat_or (cp1, cp2, _) ->
        let (vals1, exns1) = split_pattern cp1 in
        let (vals2, exns2) = split_pattern cp2 in
        ((combine_opts (into cpat) vals1 vals2),
          (combine_opts (into cpat) exns1 exns2)) in
  split_pattern pat
+ as --debug-prefix-map '/mnt/data1/nix/time/2024/08/12/ocaml_introspector/_build/default'='/workspace_root' -o 'lib/.Typing.objs/native/typing__Typedtree.o' '/tmp/build_9dd4b3_dune/camlasmd4d8bf.s'
Done: 93% (40/43, 3 left) (jobs: 1)                                   Running[27]: (cd _build/default && /home/mdupont/.opam/4.14.0/bin/ocamlopt.opt -w @1..3@5..28@31..39@43@46..47@49..57@61..62@67@69-40 -strict-sequence -strict-formats -short-paths -keep-locs -warn-error -8-9-26-27-37-34-11-11-32-39 -annot -verbose -dsource -g -a -o lib/Typing.cmxa lib/.Typing.objs/native/typing.cmx lib/.Typing.objs/native/typing__Builtin_attributes.cmx lib/.Typing.objs/native/typing__Shape.cmx lib/.Typing.objs/native/typing__Type_immediacy.cmx lib/.Typing.objs/native/typing__Types.cmx lib/.Typing.objs/native/typing__Typedtree.cmx)
Done: 93% (40/43, 3 left) (jobs: 1)                                   Output[27]:
+ ar rc 'lib/Typing.a' 'lib/.Typing.objs/native/typing.o' 'lib/.Typing.objs/native/typing__Builtin_attributes.o' 'lib/.Typing.objs/native/typing__Shape.o' 'lib/.Typing.objs/native/typing__Type_immediacy.o' 'lib/.Typing.objs/native/typing__Types.o' 'lib/.Typing.objs/native/typing__Typedtree.o'
+ ranlib 'lib/Typing.a'
Done: 93% (40/43, 3 left) (jobs: 1)                                   Running[28]: (cd _build/default && /home/mdupont/.opam/4.14.0/bin/ocamlopt.opt -w @1..3@5..28@31..39@43@46..47@49..57@61..62@67@69-40 -strict-sequence -strict-formats -short-paths -keep-locs -warn-error -8-9-26-27-37-34-11-11-32-39 -annot -verbose -dsource -g -shared -linkall -I lib -o lib/Typing.cmxs lib/Typing.cmxa)
Done: 93% (40/43, 3 left) (jobs: 1)                                   Done: 97% (42/43, 1 left) (jobs: 1)                                   Output[28]:
+ as --debug-prefix-map '/mnt/data1/nix/time/2024/08/12/ocaml_introspector/_build/default'='/workspace_root' -o 'lib/Typing.cmxs.startup.o' '/tmp/build_9dd4b3_dune/camlstartup027e81.s'
+ gcc -shared  -o 'lib/Typing.cmxs'  '-Llib' '-L/home/mdupont/.opam/4.14.0/lib/ocaml'  'lib/Typing.cmxs.startup.o' 'lib/Typing.a' 
Done: 97% (42/43, 1 left) (jobs: 1)                                   